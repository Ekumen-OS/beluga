
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Beluga: beluga Namespace Reference &#8212; Beluga  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../../../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../../../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../../../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=cc8b88f9" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../../../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../../../../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="../../../../../../../_static/design-tabs.js?v=36754332"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'packages/beluga/docs/_doxygen/generated/reference/html/namespacebeluga';</script>
    <script src="../../../../../../../_static/custom.js?v=b6861115"></script>
    <link rel="icon" href="../../../../../../../_static/logo_200x200.png"/>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="&#39;Thu May 9 11:24:59 2024 -0300, 123ea96&#39;"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../../../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../../../../_static/logo_with_name_light.png" class="logo__image only-light" alt="Beluga  documentation - Home"/>
    <script>document.write(`<img src="../../../../../../../_static/logo_with_name_dark.png" class="logo__image only-dark" alt="Beluga  documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../../../../../index.html">
                    Overview
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../getting-started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../getting-started/quickstart.html">Quickstart</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/key-concepts.html">Key concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/design-principles.html">Design principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/architecture.html">Architecture</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/using-beluga-amcl.html">Using Beluga AMCL on an AMR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/extending-beluga.html">Extending Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/profiling-beluga.html">Profiling Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/benchmarking-beluga.html">Benchmarking Beluga</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../tutorials/particle-filtering.html">Primer on Particle Filtering with Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../tutorials/nav2-integration.html">Using Beluga with Nav2</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Packages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../beluga_ros/docs/index.html">beluga_ros</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../beluga_amcl/docs/index.html">beluga_amcl</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Roadmap</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../roadmap/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../roadmap/releases.html">Releases</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../resources/bibliography.html">Bibliography</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../about/rationale.html">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../about/contact.html">Contact</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/Ekumen-OS/beluga" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../../../../../_sources/packages/beluga/docs/_doxygen/generated/reference/html/namespacebeluga.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>beluga Namespace Reference</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="beluga-namespace-reference">
<h1>beluga Namespace Reference<a class="headerlink" href="#beluga-namespace-reference" title="Link to this heading">#</a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Beluga: beluga Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Beluga
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">beluga Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main Beluga namespace.  
<a href="namespacebeluga.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1AmclParams.html">AmclParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing parameters for the Adaptive Monte Carlo Localization (AMCL) implementation.  <a href="structbeluga_1_1AmclParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Amcl.html">Amcl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Adaptive Monte Carlo Localization (AMCL) algorithm.  <a href="classbeluga_1_1Amcl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ExponentialFilter.html">ExponentialFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable type implementing an exponential filter.  <a href="classbeluga_1_1ExponentialFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Bresenham2i.html">Bresenham2i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bresenham's 2D line drawing algorithm, optimized for integer arithmetic.  <a href="classbeluga_1_1Bresenham2i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Ray2d.html">Ray2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Castable 2D ray.  <a href="classbeluga_1_1Ray2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1spatial__hash.html">spatial_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable class, allowing to calculate the hash of a particle state.  <a href="structbeluga_1_1spatial__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01std_1_1array_3_01T_00_01N_01_4_00_01std_1_1enable__if__t_3_01st82aee1c4aa004416efdc2dd54a3ad958.html">spatial_hash&lt; std::array&lt; T, N &gt;, std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt;, void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for arrays.  <a href="classbeluga_1_1spatial__hash_3_01std_1_1array_3_01T_00_01N_01_4_00_01std_1_1enable__if__t_3_01st82aee1c4aa004416efdc2dd54a3ad958.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01Tuple_3_01Types_8_8_8_01_4_00_01std_1_1enable__if__t_3_07std_1_7c7412bd4d4b17eb2e661212dfcf682d.html">spatial_hash&lt; Tuple&lt; Types... &gt;, std::enable_if_t&lt;(std::is_arithmetic_v&lt; Types &gt; &amp;&amp;...), void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for tuples.  <a href="classbeluga_1_1spatial__hash_3_01Tuple_3_01Types_8_8_8_01_4_00_01std_1_1enable__if__t_3_07std_1_7c7412bd4d4b17eb2e661212dfcf682d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01Sophus_1_1SE2d_00_01void_01_4.html">spatial_hash&lt; Sophus::SE2d, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ThrunRecoveryProbabilityEstimator.html">ThrunRecoveryProbabilityEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random particle probability estimator.  <a href="classbeluga_1_1ThrunRecoveryProbabilityEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of generic, non-threadsafe circular array.  <a href="classbeluga_1_1CircularArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleContainer.html">TupleContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for a tuple of containers.  <a href="classbeluga_1_1TupleContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleContainer_3_01InternalContainer_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html">TupleContainer&lt; InternalContainer, std::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a tuple of containers, with an interface that looks like a container of tuples.  <a href="classbeluga_1_1TupleContainer_3_01InternalContainer_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleVector.html">TupleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a tuple of vectors with the default allocator.  <a href="classbeluga_1_1TupleVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1DifferentialDriveModelParam.html">DifferentialDriveModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters to construct a <a class="el" href="classbeluga_1_1DifferentialDriveModel.html" title="Sampled odometry model for a differential drive.">DifferentialDriveModel</a> instance.  <a href="structbeluga_1_1DifferentialDriveModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1DifferentialDriveModel.html">DifferentialDriveModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled odometry model for a differential drive.  <a href="classbeluga_1_1DifferentialDriveModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1OmnidirectionalDriveModelParam.html">OmnidirectionalDriveModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters to construct an <a class="el" href="classbeluga_1_1OmnidirectionalDriveModel.html" title="Sampled odometry model for an omnidirectional drive.">OmnidirectionalDriveModel</a> instance.  <a href="structbeluga_1_1OmnidirectionalDriveModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1OmnidirectionalDriveModel.html">OmnidirectionalDriveModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled odometry model for an omnidirectional drive.  <a href="classbeluga_1_1OmnidirectionalDriveModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1StationaryModel.html">StationaryModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stationary motion model.  <a href="classbeluga_1_1StationaryModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of policy.  <a href="structbeluga_1_1policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1policy__base.html">policy_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail for a policy base object.  <a href="structbeluga_1_1policy__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of the <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html" title="Forward declaration of the multivariate_distribution_traits class template.">multivariate_distribution_traits</a> class template.  <a href="structbeluga_1_1multivariate__distribution__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is7335572249efb8242f8ba7b16eaa7821.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::EigenBase&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from <code>Eigen::EigenBase</code>.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is7335572249efb8242f8ba7b16eaa7821.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is108ecb65e882d1fe2fc8b637bf46b34c.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SO2Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SO2Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is108ecb65e882d1fe2fc8b637bf46b34c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1ise7ac88d52952e6533296e162494fd0f1.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SE2Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SE2Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1ise7ac88d52952e6533296e162494fd0f1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateNormalDistributionParam.html">MultivariateNormalDistributionParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate normal distribution parameter set class.  <a href="classbeluga_1_1MultivariateNormalDistributionParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateNormalDistribution.html">MultivariateNormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate normal distribution.  <a href="classbeluga_1_1MultivariateNormalDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for a multivariate uniform distribution.  <a href="classbeluga_1_1MultivariateUniformDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01Eigen_1_1AlignedBox2d_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE2d, Eigen::AlignedBox2d &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for bounding regions in 2D space.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01Eigen_1_1AlignedBox2d_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE3d_00_01Eigen_1_1AlignedBox3d_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE3d, Eigen::AlignedBox3d &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for bounding regions in 3D space.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE3d_00_01Eigen_1_1AlignedBox3d_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01OccupancyGrid_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE2d, OccupancyGrid &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for occupancy grids.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01OccupancyGrid_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1BeamModelParam.html">BeamModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1BeamSensorModel.html" title="Beam sensor model for range finders.">BeamSensorModel</a> instance.  <a href="structbeluga_1_1BeamModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BeamSensorModel.html">BeamSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beam sensor model for range finders.  <a href="classbeluga_1_1BeamSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1BearingModelParam.html">BearingModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1BearingSensorModel.html" title="Generic bearing sensor model, for both 2D and 3D state types.">BearingSensorModel</a> instance.  <a href="structbeluga_1_1BearingModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic bearing sensor model, for both 2D and 3D state types.  <a href="classbeluga_1_1BearingSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseDenseGrid2.html">BaseDenseGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense 2D grid base type.  <a href="classbeluga_1_1BaseDenseGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic 3D landmark map datatype.  <a href="classbeluga_1_1LandmarkMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseLaserScan.html">BaseLaserScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laser scan 2D base type.  <a href="classbeluga_1_1BaseLaserScan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseLinearGrid2.html">BaseLinearGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear 2D grid base type.  <a href="classbeluga_1_1BaseLinearGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a cell of a N dimensional NDT cell.  <a href="structbeluga_1_1NDTCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseOccupancyGrid2.html">BaseOccupancyGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occupancy 2D grid base type.  <a href="classbeluga_1_1BaseOccupancyGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseRegularGrid2.html">BaseRegularGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regularly spaced 2D grid base type.  <a href="classbeluga_1_1BaseRegularGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1SparseValueGrid.html">SparseValueGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 2D sparse value regular grid.  <a href="classbeluga_1_1SparseValueGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ValueGrid2.html">ValueGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 2D linear value grid.  <a href="classbeluga_1_1ValueGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkModelParam.html">LandmarkModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1LandmarkSensorModel.html" title="Generic landmark model for discrete detection sensors (both 2D and 3D).">LandmarkSensorModel</a> instance (both 2D and 3D).  <a href="structbeluga_1_1LandmarkModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic landmark model for discrete detection sensors (both 2D and 3D).  <a href="classbeluga_1_1LandmarkSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LikelihoodFieldModelParam.html">LikelihoodFieldModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1LikelihoodFieldModel.html" title="Likelihood field sensor model for range finders.">LikelihoodFieldModel</a> instance.  <a href="structbeluga_1_1LikelihoodFieldModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LikelihoodFieldModel.html">LikelihoodFieldModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Likelihood field sensor model for range finders.  <a href="classbeluga_1_1LikelihoodFieldModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1NDTModelParam.html">NDTModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1NDTSensorModel.html" title="NDT sensor model for range finders.">NDTSensorModel</a> instance.  <a href="structbeluga_1_1NDTModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1NDTSensorModel.html">NDTSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NDT sensor model for range finders.  <a href="classbeluga_1_1NDTSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common traits of all particle types. See <a class="el" href="ParticlePage.html">Page</a> requirements as well.  <a href="structbeluga_1_1particle__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Numeric.html">Numeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating strongly typed numeric types.  <a href="classbeluga_1_1Numeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns true if T is a tuple-like type.  <a href="structbeluga_1_1is__tuple__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1common__tuple__type.html">common_tuple_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that computes a common tuple type given two tuple-like types T and U.  <a href="structbeluga_1_1common__tuple__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1common__tuple__type_3_01T_00_01U_00_01std_1_1index__sequence_3_01I_8_8_8_01_4_01_4.html">common_tuple_type&lt; T, U, std::index_sequence&lt; I... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1common__tuple__type.html" title="Meta-function that computes a common tuple type given two tuple-like types T and U.">common_tuple_type</a></code> specialization for <code>std::index_sequence</code>.  <a href="structbeluga_1_1common__tuple__type_3_01T_00_01U_00_01std_1_1index__sequence_3_01I_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__common__tuple__type.html">has_common_tuple_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that checks for the existence of a common tuple type.  <a href="structbeluga_1_1has__common__tuple__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__common__tuple__type_3_01T_00_01U_00_01std_1_1void__t_3_01common__tuple__typ87797e8c898985f6b7323492f6753a83.html">has_common_tuple_type&lt; T, U, std::void_t&lt; common_tuple_type_t&lt; T, U &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1has__common__tuple__type.html" title="Meta-function that checks for the existence of a common tuple type.">has_common_tuple_type</a></code> specialization for tuple-like types T and U for which a common tuple type exists.  <a href="structbeluga_1_1has__common__tuple__type_3_01T_00_01U_00_01std_1_1void__t_3_01common__tuple__typ87797e8c898985f6b7323492f6753a83.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns the tuple index of the element whose type is T.  <a href="structbeluga_1_1tuple__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__single__element.html">has_single_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns true if there is a single element of type T in the tuple-like type.  <a href="structbeluga_1_1has__single__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1decay__tuple__like.html">decay_tuple_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that decays a tuple like type and its members.  <a href="structbeluga_1_1decay__tuple__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1decay__tuple__like_3_01TupleLike_3_01Args_8_8_8_01_4_00_01std_1_1enable__if__t_3ee802d0cdb58b24411f7d7c175ec0540.html">decay_tuple_like&lt; TupleLike&lt; Args... &gt;, std::enable_if_t&lt; is_tuple_like_v&lt; std::decay_t&lt; TupleLike&lt; Args... &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1decay__tuple__like.html" title="Meta-function that decays a tuple like type and its members.">decay_tuple_like</a></code> specialization for tuples.  <a href="structbeluga_1_1decay__tuple__like_3_01TupleLike_3_01Args_8_8_8_01_4_00_01std_1_1enable__if__t_3ee802d0cdb58b24411f7d7c175ec0540.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkPositionDetection.html">LandmarkPositionDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Landmark bearing detection data.  <a href="structbeluga_1_1LandmarkPositionDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkBearingDetection.html">LandmarkBearingDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Landmark bearing detection data.  <a href="structbeluga_1_1LandmarkBearingDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1IndexingIterator.html">IndexingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator for any indexable container.  <a href="classbeluga_1_1IndexingIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04edda41f9d87d101fa8dd0c7f965743"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a04edda41f9d87d101fa8dd0c7f965743"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">RollingWindow</a> = <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5aa38f8eba9e293be57492aa18397a225a">CircularArrayFeatureFlags::kRolloverOnWrite</a>|<a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5ad2b5d1942cd95644c792b766cebcdfbf">CircularArrayFeatureFlags::kExtrapolateOnRead</a>|<a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5a65589df174cbdb08dcee4d419d84912f">CircularArrayFeatureFlags::kLayoutReversal</a> &gt;</td></tr>
<tr class="memdesc:a04edda41f9d87d101fa8dd0c7f965743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient type alias for a circular array that behaves like a rolling window.  <a href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">More...</a><br /></td></tr>
<tr class="separator:a04edda41f9d87d101fa8dd0c7f965743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memTemplParams" colspan="2"><a id="a51cbced5170bfe37a85ef0a454b4ade0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a51cbced5170bfe37a85ef0a454b4ade0">Vector</a> = std::vector&lt; T, std::allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a51cbced5170bfe37a85ef0a454b4ade0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a vector with the default allocator. <br /></td></tr>
<tr class="separator:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memTemplParams" colspan="2"><a id="a9d92f9d833e5def9bea860e52f64a5b6"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9d92f9d833e5def9bea860e52f64a5b6">any_policy</a> = <a class="el" href="structbeluga_1_1policy.html">policy</a>&lt; std::function&lt; bool(Args...)&gt; &gt;</td></tr>
<tr class="memdesc:a9d92f9d833e5def9bea860e52f64a5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type erased policy. <br /></td></tr>
<tr class="separator:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7804cf035e3e2c218773a71ee9f3b0de"><td class="memItemLeft" align="right" valign="top"><a id="a7804cf035e3e2c218773a71ee9f3b0de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a7804cf035e3e2c218773a71ee9f3b0de">Weight</a> = <a class="el" href="classbeluga_1_1Numeric.html">Numeric</a>&lt; double, struct WeightTag &gt;</td></tr>
<tr class="memdesc:a7804cf035e3e2c218773a71ee9f3b0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight type, as a strongly typed <code>double</code>. <br /></td></tr>
<tr class="separator:a7804cf035e3e2c218773a71ee9f3b0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f17811828f632529bca9b868d8c4d12"><td class="memItemLeft" align="right" valign="top"><a id="a5f17811828f632529bca9b868d8c4d12"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5f17811828f632529bca9b868d8c4d12">Cluster</a> = <a class="el" href="classbeluga_1_1Numeric.html">Numeric</a>&lt; std::size_t, struct ClusterTag &gt;</td></tr>
<tr class="memdesc:a5f17811828f632529bca9b868d8c4d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster type, as a strongly typed <code>std::size_t</code>. <br /></td></tr>
<tr class="separator:a5f17811828f632529bca9b868d8c4d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memTemplParams" colspan="2"><a id="aff3ca0663c7a13b23953e9460e8b4c8a"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff3ca0663c7a13b23953e9460e8b4c8a">BearingSensorModel2d</a> = <a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE2d &gt;</td></tr>
<tr class="memdesc:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks bearing detection for 2D state types. <br /></td></tr>
<tr class="separator:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845217430a786d79ecc03b186504b6b0"><td class="memTemplParams" colspan="2"><a id="a845217430a786d79ecc03b186504b6b0"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:a845217430a786d79ecc03b186504b6b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a845217430a786d79ecc03b186504b6b0">BearingSensorModel3d</a> = <a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE3d &gt;</td></tr>
<tr class="memdesc:a845217430a786d79ecc03b186504b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks bearing detection for 3D state types. <br /></td></tr>
<tr class="separator:a845217430a786d79ecc03b186504b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26305234e807524dd077b13ae21b1dfd"><td class="memItemLeft" align="right" valign="top"><a id="a26305234e807524dd077b13ae21b1dfd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a26305234e807524dd077b13ae21b1dfd">NDTCell2d</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 2, double &gt;</td></tr>
<tr class="memdesc:a26305234e807524dd077b13ae21b1dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2D NDT cell with double representation. <br /></td></tr>
<tr class="separator:a26305234e807524dd077b13ae21b1dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfe19eadacc31d25777adc55929a123"><td class="memItemLeft" align="right" valign="top"><a id="abcfe19eadacc31d25777adc55929a123"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#abcfe19eadacc31d25777adc55929a123">NDTCell2f</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 2, float &gt;</td></tr>
<tr class="memdesc:abcfe19eadacc31d25777adc55929a123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2D NDT cell with float representation. <br /></td></tr>
<tr class="separator:abcfe19eadacc31d25777adc55929a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a678bbddd479148342d699c0a36ed85"><td class="memItemLeft" align="right" valign="top"><a id="a5a678bbddd479148342d699c0a36ed85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5a678bbddd479148342d699c0a36ed85">NDTCell3d</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 3, double &gt;</td></tr>
<tr class="memdesc:a5a678bbddd479148342d699c0a36ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3D NDT cell with double representation. <br /></td></tr>
<tr class="separator:a5a678bbddd479148342d699c0a36ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde3da44e12ce88066174cbdf63484f"><td class="memItemLeft" align="right" valign="top"><a id="aecde3da44e12ce88066174cbdf63484f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aecde3da44e12ce88066174cbdf63484f">NDTCell3f</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 3, float &gt;</td></tr>
<tr class="memdesc:aecde3da44e12ce88066174cbdf63484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3D NDT cell with float representation. <br /></td></tr>
<tr class="separator:aecde3da44e12ce88066174cbdf63484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memTemplParams" colspan="2"><a id="abdb1a8b8eea1cc0042f8a6af18dae88b"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#abdb1a8b8eea1cc0042f8a6af18dae88b">LandmarkSensorModel2d</a> = <a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE2d &gt;</td></tr>
<tr class="memdesc:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks for 2D state types. <br /></td></tr>
<tr class="separator:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda37046f0ae0f34cc32d4375a305b39"><td class="memTemplParams" colspan="2"><a id="acda37046f0ae0f34cc32d4375a305b39"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:acda37046f0ae0f34cc32d4375a305b39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#acda37046f0ae0f34cc32d4375a305b39">LandmarkSensorModel3d</a> = <a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE3d &gt;</td></tr>
<tr class="memdesc:acda37046f0ae0f34cc32d4375a305b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks for 3D state types. <br /></td></tr>
<tr class="separator:acda37046f0ae0f34cc32d4375a305b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac55da7142ee7f5d5daec24943726cee"><td class="memTemplParams" colspan="2"><a id="aac55da7142ee7f5d5daec24943726cee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aac55da7142ee7f5d5daec24943726cee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aac55da7142ee7f5d5daec24943726cee">state_t</a> = typename <a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a>&lt; T &gt;::state_type</td></tr>
<tr class="memdesc:aac55da7142ee7f5d5daec24943726cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that returns the state type given a particle type. <br /></td></tr>
<tr class="separator:aac55da7142ee7f5d5daec24943726cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507b3341999e969684415b2bff7fad52"><td class="memTemplParams" colspan="2"><a id="a507b3341999e969684415b2bff7fad52"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a507b3341999e969684415b2bff7fad52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a507b3341999e969684415b2bff7fad52">weight_t</a> = typename <a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a>&lt; T &gt;::weight_type</td></tr>
<tr class="memdesc:a507b3341999e969684415b2bff7fad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that returns the weight type given a particle type. <br /></td></tr>
<tr class="separator:a507b3341999e969684415b2bff7fad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memTemplParams" colspan="2"><a id="a9a46a50fd14023bdb2fcf0b9aa86434f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9a46a50fd14023bdb2fcf0b9aa86434f">common_tuple_type_t</a> = typename <a class="el" href="structbeluga_1_1common__tuple__type.html">common_tuple_type</a>&lt; T, U &gt;::type</td></tr>
<tr class="memdesc:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1common__tuple__type.html" title="Meta-function that computes a common tuple type given two tuple-like types T and U.">common_tuple_type</a></code>. <br /></td></tr>
<tr class="separator:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memTemplParams" colspan="2"><a id="a7fe08608971c8c79a6f92a3b5b7ef089"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a7fe08608971c8c79a6f92a3b5b7ef089">tuple_index_t</a> = typename <a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a>&lt; T, TupleLike &gt;::type</td></tr>
<tr class="memdesc:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1tuple__index.html" title="Meta-function that returns the tuple index of the element whose type is T.">tuple_index</a></code>. <br /></td></tr>
<tr class="separator:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memTemplParams" colspan="2"><a id="a5112eb59b4a2ecbb8fa5df915d96c043"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5112eb59b4a2ecbb8fa5df915d96c043">decay_tuple_like_t</a> = typename <a class="el" href="structbeluga_1_1decay__tuple__like.html">decay_tuple_like</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1decay__tuple__like.html" title="Meta-function that decays a tuple like type and its members.">decay_tuple_like</a></code>. <br /></td></tr>
<tr class="separator:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3fd6c08450af2a226fbb4f87d19736"><td class="memItemLeft" align="right" valign="top"><a id="a3f3fd6c08450af2a226fbb4f87d19736"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3f3fd6c08450af2a226fbb4f87d19736">LandmarkCategory</a> = uint32_t</td></tr>
<tr class="memdesc:a3f3fd6c08450af2a226fbb4f87d19736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent landmark categories. <br /></td></tr>
<tr class="separator:a3f3fd6c08450af2a226fbb4f87d19736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba152cf80db0f1b6d33cf85ecaa77513"><td class="memItemLeft" align="right" valign="top"><a id="aba152cf80db0f1b6d33cf85ecaa77513"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aba152cf80db0f1b6d33cf85ecaa77513">LandmarkPosition3</a> = Eigen::Vector3d</td></tr>
<tr class="memdesc:aba152cf80db0f1b6d33cf85ecaa77513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of a landmark in the world reference frame. <br /></td></tr>
<tr class="separator:aba152cf80db0f1b6d33cf85ecaa77513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db80e6730e2ace4a3d2536de5f90883"><td class="memItemLeft" align="right" valign="top"><a id="a2db80e6730e2ace4a3d2536de5f90883"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a2db80e6730e2ace4a3d2536de5f90883">LandmarkBearing3</a> = Eigen::Vector3d</td></tr>
<tr class="memdesc:a2db80e6730e2ace4a3d2536de5f90883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bearing of a landmark in the sensor reference frame. <br /></td></tr>
<tr class="separator:a2db80e6730e2ace4a3d2536de5f90883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2cc9d22f63d2e373431b4560a7761d"><td class="memItemLeft" align="right" valign="top"><a id="aef2cc9d22f63d2e373431b4560a7761d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aef2cc9d22f63d2e373431b4560a7761d">LandmarkMapBoundaries</a> = Eigen::AlignedBox3d</td></tr>
<tr class="memdesc:aef2cc9d22f63d2e373431b4560a7761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundaries of a landmark map. <br /></td></tr>
<tr class="separator:aef2cc9d22f63d2e373431b4560a7761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00fad2156828ca3126f9a8a94359a0c5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a> : int { <b>kNone</b> = 0x00
, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5aa38f8eba9e293be57492aa18397a225a">kRolloverOnWrite</a> = 0x01
, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5ad2b5d1942cd95644c792b766cebcdfbf">kExtrapolateOnRead</a> = 0x02
, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5a65589df174cbdb08dcee4d419d84912f">kLayoutReversal</a> = 0x04
 }</td></tr>
<tr class="memdesc:a00fad2156828ca3126f9a8a94359a0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature flags for circular arrays.  <a href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">More...</a><br /></td></tr>
<tr class="separator:a00fad2156828ca3126f9a8a94359a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3356c1b099bda88b4dfda8ff230bac88"><td class="memTemplParams" colspan="2">template&lt;class Range , class DistanceFunction , class NeighborsFunction &gt; </td></tr>
<tr class="memitem:a3356c1b099bda88b4dfda8ff230bac88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3356c1b099bda88b4dfda8ff230bac88">nearest_obstacle_distance_map</a> (Range &amp;&amp;obstacle_map, DistanceFunction &amp;&amp;distance_function, NeighborsFunction &amp;&amp;neighbors_function)</td></tr>
<tr class="memdesc:a3356c1b099bda88b4dfda8ff230bac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map where the value of each cell is the distance to the nearest obstacle.  <a href="namespacebeluga.html#a3356c1b099bda88b4dfda8ff230bac88">More...</a><br /></td></tr>
<tr class="separator:a3356c1b099bda88b4dfda8ff230bac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879996e3d483a908a7d5f706ac303b88"><td class="memTemplParams" colspan="2">template&lt;class Range , std::enable_if_t&lt;!is_particle_range_v&lt; Range &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a879996e3d483a908a7d5f706ac303b88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a879996e3d483a908a7d5f706ac303b88">effective_sample_size</a> (Range &amp;&amp;range)</td></tr>
<tr class="memdesc:a879996e3d483a908a7d5f706ac303b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the ESS of a given a range of weights.  <a href="namespacebeluga.html#a879996e3d483a908a7d5f706ac303b88">More...</a><br /></td></tr>
<tr class="separator:a879996e3d483a908a7d5f706ac303b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcec94ef6e5c1effabe7cced2982d8ae"><td class="memTemplParams" colspan="2">template&lt;class Range , class WeightsRange , class Scalar &gt; </td></tr>
<tr class="memitem:adcec94ef6e5c1effabe7cced2982d8ae"><td class="memTemplItemLeft" align="right" valign="top">Sophus::Matrix2&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#adcec94ef6e5c1effabe7cced2982d8ae">calculate_covariance</a> (Range &amp;&amp;range, WeightsRange &amp;&amp;normalized_weights, const Sophus::Vector2&lt; Scalar &gt; &amp;mean)</td></tr>
<tr class="memdesc:adcec94ef6e5c1effabe7cced2982d8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the covariance of a range given its mean and the weights of each element.  <a href="namespacebeluga.html#adcec94ef6e5c1effabe7cced2982d8ae">More...</a><br /></td></tr>
<tr class="separator:adcec94ef6e5c1effabe7cced2982d8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556fb20721eaea6b5a2d4b86ce603b8"><td class="memTemplParams" colspan="2">template&lt;class Range , class Scalar &gt; </td></tr>
<tr class="memitem:a6556fb20721eaea6b5a2d4b86ce603b8"><td class="memTemplItemLeft" align="right" valign="top">Sophus::Matrix2&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a6556fb20721eaea6b5a2d4b86ce603b8">calculate_covariance</a> (Range &amp;&amp;range, const Sophus::Vector2&lt; Scalar &gt; &amp;mean)</td></tr>
<tr class="separator:a6556fb20721eaea6b5a2d4b86ce603b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8114604160ec3d3fd272f183f621f3"><td class="memTemplParams" colspan="2">template&lt;class Poses , class Weights , class Pose  = ranges::range_value_t&lt;Poses&gt;, class Scalar  = typename Pose::Scalar, typename  = std::enable_if_t&lt;std::is_same_v&lt;Pose, typename Sophus::SE2&lt;Scalar&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3f8114604160ec3d3fd272f183f621f3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Sophus::SE2&lt; Scalar &gt;, Sophus::Matrix3&lt; Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3f8114604160ec3d3fd272f183f621f3">estimate</a> (Poses &amp;&amp;poses, Weights &amp;&amp;weights)</td></tr>
<tr class="memdesc:a3f8114604160ec3d3fd272f183f621f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair consisting of the estimated mean pose and its covariance.  <a href="namespacebeluga.html#a3f8114604160ec3d3fd272f183f621f3">More...</a><br /></td></tr>
<tr class="separator:a3f8114604160ec3d3fd272f183f621f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992598bc475f99f59e5b32b06caf854b"><td class="memTemplParams" colspan="2">template&lt;class Poses , class Pose  = ranges::range_value_t&lt;Poses&gt;, class Scalar  = typename Pose::Scalar, typename  = std::enable_if_t&lt;std::is_same_v&lt;Pose, typename Sophus::SE2&lt;Scalar&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a992598bc475f99f59e5b32b06caf854b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Sophus::SE2&lt; Scalar &gt;, Sophus::Matrix3&lt; Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a992598bc475f99f59e5b32b06caf854b">estimate</a> (Poses &amp;&amp;poses)</td></tr>
<tr class="memdesc:a992598bc475f99f59e5b32b06caf854b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes mean and covariance Returns a pair consisting of the estimated mean pose and its covariance.  <a href="namespacebeluga.html#a992598bc475f99f59e5b32b06caf854b">More...</a><br /></td></tr>
<tr class="separator:a992598bc475f99f59e5b32b06caf854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223b23ff16126a77c01a5c636bd4f51f"><td class="memItemLeft" align="right" valign="top"><a id="a223b23ff16126a77c01a5c636bd4f51f"></a>
constexpr <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a223b23ff16126a77c01a5c636bd4f51f">operator|</a> (<a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a> lflag, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a> rflag)</td></tr>
<tr class="memdesc:a223b23ff16126a77c01a5c636bd4f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR operator overload to combine two feature flags in a single mask-like flag. <br /></td></tr>
<tr class="separator:a223b23ff16126a77c01a5c636bd4f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02968a6d27e0b7ea3b409d54471da135"><td class="memItemLeft" align="right" valign="top"><a id="a02968a6d27e0b7ea3b409d54471da135"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a02968a6d27e0b7ea3b409d54471da135">operator&amp;</a> (<a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a> mask, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">CircularArrayFeatureFlags</a> flag)</td></tr>
<tr class="memdesc:a02968a6d27e0b7ea3b409d54471da135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND operator overload to check of the presence of a feature <code>flag</code> in a feature <code>mask</code>. <br /></td></tr>
<tr class="separator:a02968a6d27e0b7ea3b409d54471da135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ac1c2126fbec7a8720dc2ea5d06c60dd0">operator&lt;&lt;</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array, T value)</td></tr>
<tr class="memdesc:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient stream operator overload to push a <code>value</code> to a circular <code>array</code>.  <a href="namespacebeluga.html#ac1c2126fbec7a8720dc2ea5d06c60dd0">More...</a><br /></td></tr>
<tr class="separator:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272f96f28f3712285271163e6a6f7684"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a272f96f28f3712285271163e6a6f7684"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a272f96f28f3712285271163e6a6f7684">get</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a272f96f28f3712285271163e6a6f7684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an lvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a272f96f28f3712285271163e6a6f7684">More...</a><br /></td></tr>
<tr class="separator:a272f96f28f3712285271163e6a6f7684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212f42567d6335b60c5e3f631740e36"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a2212f42567d6335b60c5e3f631740e36"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a2212f42567d6335b60c5e3f631740e36">get</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;array) noexcept</td></tr>
<tr class="memdesc:a2212f42567d6335b60c5e3f631740e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an rvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a2212f42567d6335b60c5e3f631740e36">More...</a><br /></td></tr>
<tr class="separator:a2212f42567d6335b60c5e3f631740e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce63db52fec5f22604b6da1c06004e8"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a3ce63db52fec5f22604b6da1c06004e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3ce63db52fec5f22604b6da1c06004e8">get</a> (const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a3ce63db52fec5f22604b6da1c06004e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant lvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a3ce63db52fec5f22604b6da1c06004e8">More...</a><br /></td></tr>
<tr class="separator:a3ce63db52fec5f22604b6da1c06004e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbbb813b34da192ec780e769e13254b"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:afbbbb813b34da192ec780e769e13254b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#afbbbb813b34da192ec780e769e13254b">get</a> (const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;array) noexcept</td></tr>
<tr class="memdesc:afbbbb813b34da192ec780e769e13254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant rvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#afbbbb813b34da192ec780e769e13254b">More...</a><br /></td></tr>
<tr class="separator:afbbbb813b34da192ec780e769e13254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35228f88e4dd147943dfd594b25444c5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F, CircularArrayFeatureFlags G&gt; </td></tr>
<tr class="memitem:a35228f88e4dd147943dfd594b25444c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a35228f88e4dd147943dfd594b25444c5">swap</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;a, <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, G &gt; &amp;b)</td></tr>
<tr class="memdesc:a35228f88e4dd147943dfd594b25444c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps arrays <code>a</code> and <code>b</code>.  <a href="namespacebeluga.html#a35228f88e4dd147943dfd594b25444c5">More...</a><br /></td></tr>
<tr class="separator:a35228f88e4dd147943dfd594b25444c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memTemplParams" colspan="2"><a id="a5715c8a34b7699f5309e6ffc44202cc2"></a>
template&lt;class I , class S , typename  = std::enable_if_t&lt;ranges::input_iterator&lt;I&gt; &amp;&amp; ranges::input_iterator&lt;S&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5715c8a34b7699f5309e6ffc44202cc2">TupleVector</a> (I, S) -&gt; <a class="el" href="classbeluga_1_1TupleVector.html">TupleVector</a>&lt; <a class="el" href="namespacebeluga.html#a5112eb59b4a2ecbb8fa5df915d96c043">decay_tuple_like_t</a>&lt; ranges::iter_value_t&lt; I &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a5715c8a34b7699f5309e6ffc44202cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide to construct from iterators. <br /></td></tr>
<tr class="separator:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3a16c1b4130d54628383d4dac50b1"><td class="memTemplParams" colspan="2"><a id="a13b3a16c1b4130d54628383d4dac50b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a13b3a16c1b4130d54628383d4dac50b1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a13b3a16c1b4130d54628383d4dac50b1">MultivariateNormalDistribution</a> (const T &amp;, const typename <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a>&lt; T &gt;::covariance_type &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateNormalDistribution.html">MultivariateNormalDistribution</a>&lt; typename <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a>&lt; T &gt;::result_type &gt;</td></tr>
<tr class="memdesc:a13b3a16c1b4130d54628383d4dac50b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide to deduce the correct result type. <br /></td></tr>
<tr class="separator:a13b3a16c1b4130d54628383d4dac50b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43b795348b23ec8134a8bf51dd5068b"><td class="memItemLeft" align="right" valign="top"><a id="aa43b795348b23ec8134a8bf51dd5068b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aa43b795348b23ec8134a8bf51dd5068b">MultivariateUniformDistribution</a> (const Eigen::AlignedBox2d &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE2d, Eigen::AlignedBox2d &gt;</td></tr>
<tr class="memdesc:aa43b795348b23ec8134a8bf51dd5068b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for bounding regions in SE2 space. <br /></td></tr>
<tr class="separator:aa43b795348b23ec8134a8bf51dd5068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507ebc0464246bdf725c985bff3dce6"><td class="memItemLeft" align="right" valign="top"><a id="ac507ebc0464246bdf725c985bff3dce6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ac507ebc0464246bdf725c985bff3dce6">MultivariateUniformDistribution</a> (const Eigen::AlignedBox3d &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE3d, Eigen::AlignedBox3d &gt;</td></tr>
<tr class="memdesc:ac507ebc0464246bdf725c985bff3dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for bounding regions in SE3 space. <br /></td></tr>
<tr class="separator:ac507ebc0464246bdf725c985bff3dce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68b075a1af1561921788425e0fd656"><td class="memTemplParams" colspan="2"><a id="a3a68b075a1af1561921788425e0fd656"></a>
template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a3a68b075a1af1561921788425e0fd656"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3a68b075a1af1561921788425e0fd656">MultivariateUniformDistribution</a> (const <a class="el" href="classbeluga_1_1BaseOccupancyGrid2.html">BaseOccupancyGrid2</a>&lt; Derived &gt; &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE2d, Derived &gt;</td></tr>
<tr class="memdesc:a3a68b075a1af1561921788425e0fd656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for 2D occupancy grids. <br /></td></tr>
<tr class="separator:a3a68b075a1af1561921788425e0fd656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8df97f1cdadba1ae6dfadd1ce486a"><td class="memTemplParams" colspan="2">template&lt;class Particle , class T  = state_t&lt;Particle&gt;&gt; </td></tr>
<tr class="memitem:a8aa8df97f1cdadba1ae6dfadd1ce486a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a8aa8df97f1cdadba1ae6dfadd1ce486a">make_from_state</a> (T value)</td></tr>
<tr class="memdesc:a8aa8df97f1cdadba1ae6dfadd1ce486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new particle from the given state.  <a href="namespacebeluga.html#a8aa8df97f1cdadba1ae6dfadd1ce486a">More...</a><br /></td></tr>
<tr class="separator:a8aa8df97f1cdadba1ae6dfadd1ce486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecd4522d48bf1f7b59320b62b024102"><td class="memTemplParams" colspan="2"><a id="afecd4522d48bf1f7b59320b62b024102"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:afecd4522d48bf1f7b59320b62b024102"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#afecd4522d48bf1f7b59320b62b024102">element</a> (TupleLike &amp;&amp;tuple) noexcept</td></tr>
<tr class="memdesc:afecd4522d48bf1f7b59320b62b024102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element of a tuple like object whose type is T (or a possibly const reference to T). <br /></td></tr>
<tr class="separator:afecd4522d48bf1f7b59320b62b024102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854c705ccfa38ad771b16bd4ee39d228"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a854c705ccfa38ad771b16bd4ee39d228"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a854c705ccfa38ad771b16bd4ee39d228">forward_like</a> (U &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a854c705ccfa38ad771b16bd4ee39d228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a value which has similar properties to <code>T&amp;&amp;</code>.  <a href="namespacebeluga.html#a854c705ccfa38ad771b16bd4ee39d228">More...</a><br /></td></tr>
<tr class="separator:a854c705ccfa38ad771b16bd4ee39d228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f0063a224fbb53815706d549ccd01d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a33f0063a224fbb53815706d549ccd01d">kld_condition</a> (std::size_t min, double epsilon, double z=beluga::detail::kDefaultKldZ)</td></tr>
<tr class="memdesc:a33f0063a224fbb53815706d549ccd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that verifies if the KLD condition is being satisfied.  <a href="namespacebeluga.html#a33f0063a224fbb53815706d549ccd01d">More...</a><br /></td></tr>
<tr class="separator:a33f0063a224fbb53815706d549ccd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="memItemLeft" align="right" valign="top"><a id="aff8f47028f19c4ca9fbc4ef0473c8fdd"></a>
constexpr detail::make_policy_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff8f47028f19c4ca9fbc4ef0473c8fdd">make_policy</a></td></tr>
<tr class="memdesc:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make policy function objects. <br /></td></tr>
<tr class="separator:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706431bba3d6cfb1ee0690221f3a9af9"><td class="memItemLeft" align="right" valign="top"><a id="a706431bba3d6cfb1ee0690221f3a9af9"></a>
constexpr <a class="el" href="structbeluga_1_1state__detail_1_1state__fn.html">state_detail::state_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a706431bba3d6cfb1ee0690221f3a9af9">state</a></td></tr>
<tr class="memdesc:a706431bba3d6cfb1ee0690221f3a9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for accessing the <code>state</code> of a particle. <br /></td></tr>
<tr class="separator:a706431bba3d6cfb1ee0690221f3a9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80abdff6d85df8ef392ca252ed8588c1"><td class="memItemLeft" align="right" valign="top"><a id="a80abdff6d85df8ef392ca252ed8588c1"></a>
constexpr <a class="el" href="structbeluga_1_1weight__detail_1_1weight__fn.html">weight_detail::weight_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a80abdff6d85df8ef392ca252ed8588c1">weight</a></td></tr>
<tr class="memdesc:a80abdff6d85df8ef392ca252ed8588c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for accessing the <code>weight</code> of a particle. <br /></td></tr>
<tr class="separator:a80abdff6d85df8ef392ca252ed8588c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df71946142fa16a5d42d198c2ca3ec"><td class="memTemplParams" colspan="2"><a id="a57df71946142fa16a5d42d198c2ca3ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a57df71946142fa16a5d42d198c2ca3ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a57df71946142fa16a5d42d198c2ca3ec">is_tuple_like_v</a> = <a class="el" href="structbeluga_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a57df71946142fa16a5d42d198c2ca3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1is__tuple__like.html" title="Meta-function that returns true if T is a tuple-like type.">is_tuple_like</a></code>. <br /></td></tr>
<tr class="separator:a57df71946142fa16a5d42d198c2ca3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb9e2396ce921ef923c703ba45f258"><td class="memTemplParams" colspan="2"><a id="ab6fb9e2396ce921ef923c703ba45f258"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab6fb9e2396ce921ef923c703ba45f258"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ab6fb9e2396ce921ef923c703ba45f258">has_common_tuple_type_v</a> = <a class="el" href="structbeluga_1_1has__common__tuple__type.html">has_common_tuple_type</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:ab6fb9e2396ce921ef923c703ba45f258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1has__common__tuple__type.html" title="Meta-function that checks for the existence of a common tuple type.">has_common_tuple_type</a></code>. <br /></td></tr>
<tr class="separator:ab6fb9e2396ce921ef923c703ba45f258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528b7d8d6f614c786f40275567ff5127"><td class="memTemplParams" colspan="2"><a id="a528b7d8d6f614c786f40275567ff5127"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:a528b7d8d6f614c786f40275567ff5127"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a528b7d8d6f614c786f40275567ff5127">tuple_index_v</a> = <a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a>&lt;T, TupleLike&gt;::value</td></tr>
<tr class="memdesc:a528b7d8d6f614c786f40275567ff5127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1tuple__index.html" title="Meta-function that returns the tuple index of the element whose type is T.">tuple_index</a></code>. <br /></td></tr>
<tr class="separator:a528b7d8d6f614c786f40275567ff5127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6cba96ed18281cbfbb37187289f58b"><td class="memTemplParams" colspan="2"><a id="aff6cba96ed18281cbfbb37187289f58b"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:aff6cba96ed18281cbfbb37187289f58b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff6cba96ed18281cbfbb37187289f58b">has_single_element_v</a> = <a class="el" href="structbeluga_1_1has__single__element.html">has_single_element</a>&lt;T, TupleLike&gt;::value</td></tr>
<tr class="memdesc:aff6cba96ed18281cbfbb37187289f58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1has__single__element.html" title="Meta-function that returns true if there is a single element of type T in the tuple-like type.">has_single_element</a></code>. <br /></td></tr>
<tr class="separator:aff6cba96ed18281cbfbb37187289f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main Beluga namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a04edda41f9d87d101fa8dd0c7f965743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04edda41f9d87d101fa8dd0c7f965743">&#9670;&nbsp;</a></span>RollingWindow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">beluga::RollingWindow</a> = typedef <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5aa38f8eba9e293be57492aa18397a225a">CircularArrayFeatureFlags::kRolloverOnWrite</a> | <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5ad2b5d1942cd95644c792b766cebcdfbf">CircularArrayFeatureFlags::kExtrapolateOnRead</a> | <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5a65589df174cbdb08dcee4d419d84912f">CircularArrayFeatureFlags::kLayoutReversal</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient type alias for a circular array that behaves like a rolling window. </p>
<p>A rolling window automatically overwrites older values, it extrapolates its last value to always seem full, and it is accessed by the front. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a00fad2156828ca3126f9a8a94359a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fad2156828ca3126f9a8a94359a0c5">&#9670;&nbsp;</a></span>CircularArrayFeatureFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacebeluga.html#a00fad2156828ca3126f9a8a94359a0c5">beluga::CircularArrayFeatureFlags</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Feature flags for circular arrays. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00fad2156828ca3126f9a8a94359a0c5aa38f8eba9e293be57492aa18397a225a"></a>kRolloverOnWrite&#160;</td><td class="fielddoc"><p>! If enabled, older values in the array are overwritten by newer values if the array has reached its maximum size already. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00fad2156828ca3126f9a8a94359a0c5ad2b5d1942cd95644c792b766cebcdfbf"></a>kExtrapolateOnRead&#160;</td><td class="fielddoc"><p>! If enabled, the back value is extrapolated for constant accesses up to the array maximum size. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00fad2156828ca3126f9a8a94359a0c5a65589df174cbdb08dcee4d419d84912f"></a>kLayoutReversal&#160;</td><td class="fielddoc"><p>! If enabled, the circular array memory layout is reversed so that values can be pushed to the front rather than the back of the array. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6556fb20721eaea6b5a2d4b86ce603b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6556fb20721eaea6b5a2d4b86ce603b8">&#9670;&nbsp;</a></span>calculate_covariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sophus::Matrix2&lt;Scalar&gt; beluga::calculate_covariance </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sophus::Vector2&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience overload that calculates the covariance of a range given its mean for the case where all samples have the same weight. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Sophus::Vector2&lt;Scalar&gt;</code>. </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type, e.g. double or float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Range to be used to calculate the covariance. </td></tr>
    <tr><td class="paramname">mean</td><td>The previously calculated mean of range. The value must be correct for the resulting covariance to be correct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated covariance, as a <code>Sophus::Matrix2&lt;Scalar&gt;</code>. </dd></dl>

</div>
</div>
<a id="adcec94ef6e5c1effabe7cced2982d8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcec94ef6e5c1effabe7cced2982d8ae">&#9670;&nbsp;</a></span>calculate_covariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class WeightsRange , class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sophus::Matrix2&lt;Scalar&gt; beluga::calculate_covariance </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightsRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>normalized_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sophus::Vector2&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the covariance of a range given its mean and the weights of each element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Sophus::Vector2&lt;Scalar&gt;</code>. </td></tr>
    <tr><td class="paramname">WeightsRange</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Scalar</code>. </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type, e.g. double or float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Range to be used to calculate the covariance. </td></tr>
    <tr><td class="paramname">normalized_weights</td><td>Range with the normalized (total weight 1.0) weights of the samples in 'range'. </td></tr>
    <tr><td class="paramname">mean</td><td>The previously calculated mean of range. The value must be correct for the resulting covariance to be correct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated covariance, as a <code>Sophus::Matrix2&lt;Scalar&gt;</code>. </dd></dl>

</div>
</div>
<a id="a879996e3d483a908a7d5f706ac303b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879996e3d483a908a7d5f706ac303b88">&#9670;&nbsp;</a></span>effective_sample_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , std::enable_if_t&lt;!is_particle_range_v&lt; Range &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::effective_sample_size </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the ESS of a given a range of weights. </p>
<p>Overload for particle ranges.</p>
<p>The effective sample size (ESS) is a figure of merit for importance sampling methods' output. It characterizes how well the target posterior distribution is approximated (as it is proportional to the efficiency of distribution parameter estimators, <a class="el" href="citelist.html#CITEREF_kong1994sequentialimputations">[3]</a>, section 4.1). It can be interpreted as the number of samples effectively approximating the distribution, and thus comparing with the total number of samples makes for a good mechanism to detect and react to performance degradation e.g. triggering a resample when the ESS falls below a fraction of the total number of samples.</p>
<p>The algorithm is based on <a class="el" href="citelist.html#CITEREF_grisetti2007selectiveresampling">[2]</a>, according to the description given in <a class="el" href="citelist.html#CITEREF_tiacheng2015resamplingmethods">[4]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/forward_range">forward range</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of weights. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992598bc475f99f59e5b32b06caf854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992598bc475f99f59e5b32b06caf854b">&#9670;&nbsp;</a></span>estimate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Poses , class Pose  = ranges::range_value_t&lt;Poses&gt;, class Scalar  = typename Pose::Scalar, typename  = std::enable_if_t&lt;std::is_same_v&lt;Pose, typename Sophus::SE2&lt;Scalar&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Sophus::SE2&lt;Scalar&gt;, Sophus::Matrix3&lt;Scalar&gt; &gt; beluga::estimate </td>
          <td>(</td>
          <td class="paramtype">Poses &amp;&amp;&#160;</td>
          <td class="paramname"><em>poses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes mean and covariance Returns a pair consisting of the estimated mean pose and its covariance. </p>
<p>Given a range of 2D poses, computes the estimated pose by averaging the translation and rotation parts, assuming all poses are equally weighted. Computes the covariance matrix of the translation parts and the circular variance of the rotation angles to create a 3x3 covariance matrix. It does not take into account the particle weights. This is appropriate for use with filter update cycles that resample the particle set at every iteration, since in that case the belief is fully represented by the spatial distribution of the particles, and the particle weights provide no additional information.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Poses</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Sophus::SE2&lt;Scalar&gt;</code>. </td></tr>
    <tr><td class="paramname">Pose</td><td>The pose value type of the given range. </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type, e.g. double or float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Poses of equally weighted 2D poses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated pose and its 3x3 covariance matrix. </dd></dl>

</div>
</div>
<a id="a3f8114604160ec3d3fd272f183f621f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8114604160ec3d3fd272f183f621f3">&#9670;&nbsp;</a></span>estimate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Poses , class Weights , class Pose  = ranges::range_value_t&lt;Poses&gt;, class Scalar  = typename Pose::Scalar, typename  = std::enable_if_t&lt;std::is_same_v&lt;Pose, typename Sophus::SE2&lt;Scalar&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Sophus::SE2&lt;Scalar&gt;, Sophus::Matrix3&lt;Scalar&gt; &gt; beluga::estimate </td>
          <td>(</td>
          <td class="paramtype">Poses &amp;&amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Weights &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair consisting of the estimated mean pose and its covariance. </p>
<p>Given a range of poses, computes the estimated pose by averaging the translation and rotation parts. Computes the covariance matrix of the translation parts and the circular variance of the rotation angles to create a 3x3 covariance matrix. It does not take into account the particle weights.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Poses</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Sophus::SE2&lt;Scalar&gt;</code>. </td></tr>
    <tr><td class="paramname">Weights</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a> type whose value type is <code>Scalar</code>. </td></tr>
    <tr><td class="paramname">Pose</td><td>The pose value type of the given range. </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type, e.g. double or float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Poses of equally weighted 2D poses. </td></tr>
    <tr><td class="paramname">weights</td><td>Poses of equally weighted 2D poses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated pose and its 3x3 covariance matrix. </dd></dl>

</div>
</div>
<a id="a854c705ccfa38ad771b16bd4ee39d228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854c705ccfa38ad771b16bd4ee39d228">&#9670;&nbsp;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto&amp;&amp; beluga::forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to a value which has similar properties to <code>T&amp;&amp;</code>. </p>
<p>Implementation taken from <a href="https://en.cppreference.com/w/cpp/utility/forward_like">https://en.cppreference.com/w/cpp/utility/forward_like</a> since this feature is only available starting with C++23.</p>
<p>The program is ill-formed if <code>T&amp;&amp;</code> is not a valid type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type from which to take the properties. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value that needs to be forwarded like type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to value of the determined type. </dd></dl>

</div>
</div>
<a id="a2212f42567d6335b60c5e3f631740e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212f42567d6335b60c5e3f631740e36">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an rvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a272f96f28f3712285271163e6a6f7684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272f96f28f3712285271163e6a6f7684">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an lvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="afbbbb813b34da192ec780e769e13254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbbb813b34da192ec780e769e13254b">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp;&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant rvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a3ce63db52fec5f22604b6da1c06004e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce63db52fec5f22604b6da1c06004e8">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant lvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a33f0063a224fbb53815706d549ccd01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f0063a224fbb53815706d549ccd01d">&#9670;&nbsp;</a></span>kld_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::kld_condition </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em> = <code>beluga::detail::kDefaultKldZ</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that verifies if the KLD condition is being satisfied. </p>
<p>The callable object will compute the minimum number of samples based on a Kullback-Leibler distance epsilon between the maximum likelihood estimate and the true distribution. <br  />
Z is the upper standard normal quantile for P, where P is the probability that the error in the estimated distribution will be less than epsilon.</p>
<p>Here are some examples: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">P   </th><th class="markdownTableHeadNone">Z    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.900   </td><td class="markdownTableBodyNone">1.28155156327703    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.950   </td><td class="markdownTableBodyNone">1.64485362793663    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.990   </td><td class="markdownTableBodyNone">2.32634787735669    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.999   </td><td class="markdownTableBodyNone">3.09023224677087   </td></tr>
</table>
<p>If the computed value is less than what the min argument specifies, then min will be returned.</p>
<p>See KLD-Sampling: Adaptive Particle Filters <a class="el" href="citelist.html#CITEREF_fox2001adaptivekldsampling">[1]</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number of particles that the callable object will return. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum distance epsilon between the maximum likelihood estimate and the true distrubution. </td></tr>
    <tr><td class="paramname">z</td><td>Upper standard normal quantile for the probability that the error in the estimated distribution is less than epsilon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype <code>(std::size_t hash) -&gt; bool</code>. <code>hash</code> is the spatial hash of the particle being added. <br  />
 The returned callable object is stateful, tracking the total number of particles and the particle clusters based on the spatial hash. <br  />
 The return value of the callable will be false when the number of particles is more than the minimum and the KLD condition is satisfied, if not it will be true. <br  />
 i.e. A return value of true means that you need to keep sampling to satisfy the condition. </dd></dl>

</div>
</div>
<a id="a8aa8df97f1cdadba1ae6dfadd1ce486a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa8df97f1cdadba1ae6dfadd1ce486a">&#9670;&nbsp;</a></span>make_from_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle , class T  = state_t&lt;Particle&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto beluga::make_from_state </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new particle from the given state. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle</td><td>The particle type to be used. </td></tr>
    <tr><td class="paramname">T</td><td>The particle state type. T must be convertible to <code>state_t&lt;Particle&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The state to make the particle from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new particle, created from the given state.</dd></dl>
<p>The new particle will have a weight equal to 1. </p>

</div>
</div>
<a id="a3356c1b099bda88b4dfda8ff230bac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3356c1b099bda88b4dfda8ff230bac88">&#9670;&nbsp;</a></span>nearest_obstacle_distance_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class DistanceFunction , class NeighborsFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::nearest_obstacle_distance_map </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>obstacle_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistanceFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>distance_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighborsFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>neighbors_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map where the value of each cell is the distance to the nearest obstacle. </p>
<p>The algorithm uses O(N) time and memory, where <code>N=ranges::size(obstacle_map)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a>. Its value type must be bool. </td></tr>
    <tr><td class="paramname">DistanceFunction</td><td>A callable type, its prototype must be (std::size_t, std::size_t) -&gt; DistanceType. DistanceType must be an scalar type. </td></tr>
    <tr><td class="paramname">NeighborsFunction</td><td>A callabe type, its prototype must be (std::size_t) -&gt; NeighborsT, where NeighborsT is a <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> with value type std::size_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obstacle_map</td><td>A map that represents obstacles in an environment. If the value of a cell is True, the cell has an obstacle. </td></tr>
    <tr><td class="paramname">distance_function</td><td>Given the indexes of two cells in the map i and j, obstacle_map(i, j) must return the distance between the two cells. </td></tr>
    <tr><td class="paramname">neighbors_function</td><td>Given the index i of one cell in the map, neighbors_function(i) returns the cell indexes of neighbor cells in the obstacle map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each cell value is the distance to the nearest object. </dd></dl>

</div>
</div>
<a id="ac1c2126fbec7a8720dc2ea5d06c60dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2126fbec7a8720dc2ea5d06c60dd0">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt;T, N, F&gt;&amp; beluga::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient stream operator overload to push a <code>value</code> to a circular <code>array</code>. </p>
<p>Functionally equivalent to a push_back() (or push_front() if the layout reversal feature is enabled). </p>

</div>
</div>
<a id="a35228f88e4dd147943dfd594b25444c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35228f88e4dd147943dfd594b25444c5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F, CircularArrayFeatureFlags G&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void beluga::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps arrays <code>a</code> and <code>b</code>. </p>
<p>This is an <code>std::swap</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
</div>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Ekumen Research
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022-2024 Ekumen, Inc..
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
  Last updated on &#39;Thu May 9 11:24:59 2024 -0300, 123ea96&#39;.
  <br/>
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>