
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Beluga: beluga Namespace Reference &#8212; Beluga  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=cc8b88f9" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../../../../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'packages/beluga/docs/_doxygen/generated/reference/html/namespacebeluga';</script>
    <script src="../../../../../../../_static/custom.js?v=b6861115"></script>
    <link rel="icon" href="../../../../../../../_static/logo_200x200.png"/>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
    <meta name="docbuild:last-update" content="&#39;Fri Dec 20 16:03:38 2024 -0300, b2748e4&#39;"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../../../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../../../../_static/logo_with_name_light.png" class="logo__image only-light" alt="Beluga  documentation - Home"/>
    <img src="../../../../../../../_static/logo_with_name_dark.png" class="logo__image only-dark pst-js-only" alt="Beluga  documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../../../../../index.html">
                    Overview
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../getting-started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../getting-started/quickstart.html">Quickstart</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/key-concepts.html">Key concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/design-principles.html">Design principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../concepts/architecture.html">Architecture</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/using-beluga-amcl.html">Using Beluga AMCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/extending-beluga.html">Extending Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/profiling-beluga.html">Profiling Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../guides/benchmarking-beluga.html">Benchmarking Beluga</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../tutorials/particle-filtering.html">Primer on Particle Filtering with Beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../tutorials/nav2-integration.html">Using Beluga with Nav2</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Packages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">beluga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../beluga_ros/docs/index.html">beluga_ros</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../beluga_amcl/docs/index.html">beluga_amcl</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Roadmap</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../roadmap/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../roadmap/releases.html">Releases</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../resources/bibliography.html">Bibliography</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../about/rationale.html">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../about/contact.html">Contact</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/Ekumen-OS/beluga" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../../../../../_sources/packages/beluga/docs/_doxygen/generated/reference/html/namespacebeluga.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>beluga Namespace Reference</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="beluga-namespace-reference">
<h1>beluga Namespace Reference<a class="headerlink" href="#beluga-namespace-reference" title="Link to this heading">#</a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Beluga: beluga Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Beluga
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">beluga Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main Beluga namespace.  
<a href="namespacebeluga.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1AmclParams.html">AmclParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing parameters for the Adaptive Monte Carlo Localization (AMCL) implementation.  <a href="structbeluga_1_1AmclParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Amcl.html">Amcl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Adaptive Monte Carlo Localization (AMCL) algorithm.  <a href="classbeluga_1_1Amcl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1ParticleClusterizerParam.html">ParticleClusterizerParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1ParticleClusterizer.html" title="Particle clusterizer implementation.">ParticleClusterizer</a> instance.  <a href="structbeluga_1_1ParticleClusterizerParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ParticleClusterizer.html">ParticleClusterizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle clusterizer implementation.  <a href="classbeluga_1_1ParticleClusterizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ExponentialFilter.html">ExponentialFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable type implementing an exponential filter.  <a href="classbeluga_1_1ExponentialFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Bresenham2i.html">Bresenham2i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bresenham's 2D line drawing algorithm, optimized for integer arithmetic.  <a href="classbeluga_1_1Bresenham2i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Ray2d.html">Ray2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Castable 2D ray.  <a href="classbeluga_1_1Ray2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1spatial__hash.html">spatial_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable class, allowing to calculate the hash of a particle state.  <a href="structbeluga_1_1spatial__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01std_1_1array_3_01T_00_01N_01_4_00_01std_1_1enable__if__t_3_01st82aee1c4aa004416efdc2dd54a3ad958.html">spatial_hash&lt; std::array&lt; T, N &gt;, std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt;, void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for arrays.  <a href="classbeluga_1_1spatial__hash_3_01std_1_1array_3_01T_00_01N_01_4_00_01std_1_1enable__if__t_3_01st82aee1c4aa004416efdc2dd54a3ad958.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01Tuple_3_01Types_8_8_8_01_4_00_01std_1_1enable__if__t_3_07std_1_7c7412bd4d4b17eb2e661212dfcf682d.html">spatial_hash&lt; Tuple&lt; Types... &gt;, std::enable_if_t&lt;(std::is_arithmetic_v&lt; Types &gt; &amp;&amp;...), void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for tuples.  <a href="classbeluga_1_1spatial__hash_3_01Tuple_3_01Types_8_8_8_01_4_00_01std_1_1enable__if__t_3_07std_1_7c7412bd4d4b17eb2e661212dfcf682d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01Sophus_1_1SE2d_00_01void_01_4.html">spatial_hash&lt; Sophus::SE2d, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1spatial__hash_3_01Sophus_1_1SE3d_00_01void_01_4.html">spatial_hash&lt; Sophus::SE3d, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ThrunRecoveryProbabilityEstimator.html">ThrunRecoveryProbabilityEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random particle probability estimator.  <a href="classbeluga_1_1ThrunRecoveryProbabilityEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of generic, non-threadsafe circular array.  <a href="classbeluga_1_1CircularArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleContainer.html">TupleContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for a tuple of containers.  <a href="classbeluga_1_1TupleContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleContainer_3_01InternalContainer_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html">TupleContainer&lt; InternalContainer, std::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a tuple of containers, with an interface that looks like a container of tuples.  <a href="classbeluga_1_1TupleContainer_3_01InternalContainer_00_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1TupleVector.html">TupleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a tuple of vectors with the default allocator.  <a href="classbeluga_1_1TupleVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1DifferentialDriveModelParam.html">DifferentialDriveModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters to construct a <a class="el" href="classbeluga_1_1DifferentialDriveModel.html" title="Sampled odometry model for a differential drive.">DifferentialDriveModel</a> instance.  <a href="structbeluga_1_1DifferentialDriveModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1DifferentialDriveModel.html">DifferentialDriveModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled odometry model for a differential drive.  <a href="classbeluga_1_1DifferentialDriveModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1OmnidirectionalDriveModelParam.html">OmnidirectionalDriveModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters to construct an <a class="el" href="classbeluga_1_1OmnidirectionalDriveModel.html" title="Sampled odometry model for an omnidirectional drive.">OmnidirectionalDriveModel</a> instance.  <a href="structbeluga_1_1OmnidirectionalDriveModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1OmnidirectionalDriveModel.html">OmnidirectionalDriveModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled odometry model for an omnidirectional drive.  <a href="classbeluga_1_1OmnidirectionalDriveModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1StationaryModel.html">StationaryModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stationary motion model.  <a href="classbeluga_1_1StationaryModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of policy.  <a href="structbeluga_1_1policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1policy__base.html">policy_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail for a policy base object.  <a href="structbeluga_1_1policy__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of the <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html" title="Forward declaration of the multivariate_distribution_traits class template.">multivariate_distribution_traits</a> class template.  <a href="structbeluga_1_1multivariate__distribution__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is7335572249efb8242f8ba7b16eaa7821.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::EigenBase&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from <code>Eigen::EigenBase</code>.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is7335572249efb8242f8ba7b16eaa7821.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is108ecb65e882d1fe2fc8b637bf46b34c.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SO2Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SO2Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is108ecb65e882d1fe2fc8b637bf46b34c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1ise7ac88d52952e6533296e162494fd0f1.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SE2Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SE2Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1ise7ac88d52952e6533296e162494fd0f1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1iscd5fdf80de344db88138b1e69a58d58d.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SO3Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SO3Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1iscd5fdf80de344db88138b1e69a58d58d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is14a8f4eaf89c5248a34012104455aef8.html">multivariate_distribution_traits&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Sophus::SE3Base&lt; T &gt;, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types derived from Sophus::SE3Base.  <a href="structbeluga_1_1multivariate__distribution__traits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is14a8f4eaf89c5248a34012104455aef8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateNormalDistributionParam.html">MultivariateNormalDistributionParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate normal distribution parameter set class.  <a href="classbeluga_1_1MultivariateNormalDistributionParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateNormalDistribution.html">MultivariateNormalDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multivariate normal distribution.  <a href="classbeluga_1_1MultivariateNormalDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for a multivariate uniform distribution.  <a href="classbeluga_1_1MultivariateUniformDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01Eigen_1_1AlignedBox2d_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE2d, Eigen::AlignedBox2d &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for bounding regions in 2D space.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01Eigen_1_1AlignedBox2d_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE3d_00_01Eigen_1_1AlignedBox3d_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE3d, Eigen::AlignedBox3d &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for bounding regions in 3D space.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE3d_00_01Eigen_1_1AlignedBox3d_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01OccupancyGrid_01_4.html">MultivariateUniformDistribution&lt; Sophus::SE2d, OccupancyGrid &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of multivariate uniform distribution for occupancy grids.  <a href="classbeluga_1_1MultivariateUniformDistribution_3_01Sophus_1_1SE2d_00_01OccupancyGrid_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1BeamModelParam.html">BeamModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1BeamSensorModel.html" title="Beam sensor model for range finders.">BeamSensorModel</a> instance.  <a href="structbeluga_1_1BeamModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BeamSensorModel.html">BeamSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beam sensor model for range finders.  <a href="classbeluga_1_1BeamSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1BearingModelParam.html">BearingModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1BearingSensorModel.html" title="Generic bearing sensor model, for both 2D and 3D state types.">BearingSensorModel</a> instance.  <a href="structbeluga_1_1BearingModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic bearing sensor model, for both 2D and 3D state types.  <a href="classbeluga_1_1BearingSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseDenseGrid2.html">BaseDenseGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense 2D grid base type.  <a href="classbeluga_1_1BaseDenseGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic 3D landmark map datatype.  <a href="classbeluga_1_1LandmarkMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseLaserScan.html">BaseLaserScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laser scan 2D base type.  <a href="classbeluga_1_1BaseLaserScan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseLinearGrid2.html">BaseLinearGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear 2D grid base type.  <a href="classbeluga_1_1BaseLinearGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a cell of a N dimensional NDT cell.  <a href="structbeluga_1_1NDTCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseOccupancyGrid2.html">BaseOccupancyGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occupancy 2D grid base type.  <a href="classbeluga_1_1BaseOccupancyGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BasePointCloud.html">BasePointCloud</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud 3D base type.  <a href="classbeluga_1_1BasePointCloud.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseRegularGrid.html">BaseRegularGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regularly spaced N dimensional grid base type.  <a href="classbeluga_1_1BaseRegularGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1BaseSparsePointCloud.html">BaseSparsePointCloud</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse Point Cloud 3D base type.  <a href="classbeluga_1_1BaseSparsePointCloud.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1SparseValueGrid.html">SparseValueGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic N dimensional sparse value regular grid.  <a href="classbeluga_1_1SparseValueGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1ValueGrid2.html">ValueGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 2D linear value grid.  <a href="classbeluga_1_1ValueGrid2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkModelParam.html">LandmarkModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1LandmarkSensorModel.html" title="Generic landmark model for discrete detection sensors (both 2D and 3D).">LandmarkSensorModel</a> instance (both 2D and 3D).  <a href="structbeluga_1_1LandmarkModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic landmark model for discrete detection sensors (both 2D and 3D).  <a href="classbeluga_1_1LandmarkSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LikelihoodFieldModelParam.html">LikelihoodFieldModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1LikelihoodFieldModel.html" title="Likelihood field sensor model for range finders.">LikelihoodFieldModel</a> instance.  <a href="structbeluga_1_1LikelihoodFieldModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1LikelihoodFieldModel.html">LikelihoodFieldModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Likelihood field sensor model for range finders.  <a href="classbeluga_1_1LikelihoodFieldModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1NDTModelParam.html">NDTModelParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1NDTSensorModel.html" title="NDT sensor model for range finders.">NDTSensorModel</a> instance.  <a href="structbeluga_1_1NDTModelParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1NDTSensorModel.html">NDTSensorModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NDT sensor model for range finders.  <a href="classbeluga_1_1NDTSensorModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common traits of all particle types. See <a class="el" href="ParticlePage.html">Page</a> requirements as well.  <a href="structbeluga_1_1particle__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1Numeric.html">Numeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for creating strongly typed numeric types.  <a href="classbeluga_1_1Numeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns true if T is a tuple-like type.  <a href="structbeluga_1_1is__tuple__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1common__tuple__type.html">common_tuple_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that computes a common tuple type given two tuple-like types T and U.  <a href="structbeluga_1_1common__tuple__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1common__tuple__type_3_01T_00_01U_00_01std_1_1index__sequence_3_01I_8_8_8_01_4_01_4.html">common_tuple_type&lt; T, U, std::index_sequence&lt; I... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1common__tuple__type.html" title="Meta-function that computes a common tuple type given two tuple-like types T and U.">common_tuple_type</a></code> specialization for <code>std::index_sequence</code>.  <a href="structbeluga_1_1common__tuple__type_3_01T_00_01U_00_01std_1_1index__sequence_3_01I_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__common__tuple__type.html">has_common_tuple_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that checks for the existence of a common tuple type.  <a href="structbeluga_1_1has__common__tuple__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__common__tuple__type_3_01T_00_01U_00_01std_1_1void__t_3_01common__tuple__typ87797e8c898985f6b7323492f6753a83.html">has_common_tuple_type&lt; T, U, std::void_t&lt; common_tuple_type_t&lt; T, U &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1has__common__tuple__type.html" title="Meta-function that checks for the existence of a common tuple type.">has_common_tuple_type</a></code> specialization for tuple-like types T and U for which a common tuple type exists.  <a href="structbeluga_1_1has__common__tuple__type_3_01T_00_01U_00_01std_1_1void__t_3_01common__tuple__typ87797e8c898985f6b7323492f6753a83.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns the tuple index of the element whose type is T.  <a href="structbeluga_1_1tuple__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1has__single__element.html">has_single_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that returns true if there is a single element of type T in the tuple-like type.  <a href="structbeluga_1_1has__single__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1decay__tuple__like.html">decay_tuple_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that decays a tuple like type and its members.  <a href="structbeluga_1_1decay__tuple__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1decay__tuple__like_3_01TupleLike_3_01Args_8_8_8_01_4_00_01std_1_1enable__if__t_3ee802d0cdb58b24411f7d7c175ec0540.html">decay_tuple_like&lt; TupleLike&lt; Args... &gt;, std::enable_if_t&lt; is_tuple_like_v&lt; std::decay_t&lt; TupleLike&lt; Args... &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structbeluga_1_1decay__tuple__like.html" title="Meta-function that decays a tuple like type and its members.">decay_tuple_like</a></code> specialization for tuples.  <a href="structbeluga_1_1decay__tuple__like_3_01TupleLike_3_01Args_8_8_8_01_4_00_01std_1_1enable__if__t_3ee802d0cdb58b24411f7d7c175ec0540.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkPositionDetection.html">LandmarkPositionDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Landmark bearing detection data.  <a href="structbeluga_1_1LandmarkPositionDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1LandmarkBearingDetection.html">LandmarkBearingDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Landmark bearing detection data.  <a href="structbeluga_1_1LandmarkBearingDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1IndexingIterator.html">IndexingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator for any indexable container.  <a href="classbeluga_1_1IndexingIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04edda41f9d87d101fa8dd0c7f965743"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a04edda41f9d87d101fa8dd0c7f965743"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">RollingWindow</a> = <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825caa38f8eba9e293be57492aa18397a225a">CircularArrayFeatureFlags::kRolloverOnWrite</a>|<a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825cad2b5d1942cd95644c792b766cebcdfbf">CircularArrayFeatureFlags::kExtrapolateOnRead</a>|<a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825ca65589df174cbdb08dcee4d419d84912f">CircularArrayFeatureFlags::kLayoutReversal</a> &gt;</td></tr>
<tr class="memdesc:a04edda41f9d87d101fa8dd0c7f965743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient type alias for a circular array that behaves like a rolling window.  <a href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">More...</a><br /></td></tr>
<tr class="separator:a04edda41f9d87d101fa8dd0c7f965743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memTemplParams" colspan="2"><a id="a51cbced5170bfe37a85ef0a454b4ade0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a51cbced5170bfe37a85ef0a454b4ade0">Vector</a> = std::vector&lt; T, std::allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a51cbced5170bfe37a85ef0a454b4ade0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a vector with the default allocator. <br /></td></tr>
<tr class="separator:a51cbced5170bfe37a85ef0a454b4ade0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9142e25bdd4e8cea7f524dc95afa78e5"><td class="memItemLeft" align="right" valign="top"><a id="a9142e25bdd4e8cea7f524dc95afa78e5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9142e25bdd4e8cea7f524dc95afa78e5">DifferentialDriveModel2d</a> = <a class="el" href="classbeluga_1_1DifferentialDriveModel.html">DifferentialDriveModel</a>&lt; Sophus::SE2d &gt;</td></tr>
<tr class="memdesc:a9142e25bdd4e8cea7f524dc95afa78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a 2D differential drive model, for convinience. <br /></td></tr>
<tr class="separator:a9142e25bdd4e8cea7f524dc95afa78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abfcaa4332ab9a79816a58bb4094dd4"><td class="memItemLeft" align="right" valign="top"><a id="a9abfcaa4332ab9a79816a58bb4094dd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9abfcaa4332ab9a79816a58bb4094dd4">DifferentialDriveModel3d</a> = <a class="el" href="classbeluga_1_1DifferentialDriveModel.html">DifferentialDriveModel</a>&lt; Sophus::SE3d &gt;</td></tr>
<tr class="memdesc:a9abfcaa4332ab9a79816a58bb4094dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a 3D differential drive model, for convinience. <br /></td></tr>
<tr class="separator:a9abfcaa4332ab9a79816a58bb4094dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memTemplParams" colspan="2"><a id="a9d92f9d833e5def9bea860e52f64a5b6"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9d92f9d833e5def9bea860e52f64a5b6">any_policy</a> = <a class="el" href="structbeluga_1_1policy.html">policy</a>&lt; std::function&lt; bool(Args...)&gt; &gt;</td></tr>
<tr class="memdesc:a9d92f9d833e5def9bea860e52f64a5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type erased policy. <br /></td></tr>
<tr class="separator:a9d92f9d833e5def9bea860e52f64a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7804cf035e3e2c218773a71ee9f3b0de"><td class="memItemLeft" align="right" valign="top"><a id="a7804cf035e3e2c218773a71ee9f3b0de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a7804cf035e3e2c218773a71ee9f3b0de">Weight</a> = <a class="el" href="classbeluga_1_1Numeric.html">Numeric</a>&lt; double, struct WeightTag &gt;</td></tr>
<tr class="memdesc:a7804cf035e3e2c218773a71ee9f3b0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight type, as a strongly typed <code>double</code>. <br /></td></tr>
<tr class="separator:a7804cf035e3e2c218773a71ee9f3b0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f17811828f632529bca9b868d8c4d12"><td class="memItemLeft" align="right" valign="top"><a id="a5f17811828f632529bca9b868d8c4d12"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5f17811828f632529bca9b868d8c4d12">Cluster</a> = <a class="el" href="classbeluga_1_1Numeric.html">Numeric</a>&lt; std::size_t, struct ClusterTag &gt;</td></tr>
<tr class="memdesc:a5f17811828f632529bca9b868d8c4d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster type, as a strongly typed <code>std::size_t</code>. <br /></td></tr>
<tr class="separator:a5f17811828f632529bca9b868d8c4d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memTemplParams" colspan="2"><a id="aff3ca0663c7a13b23953e9460e8b4c8a"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff3ca0663c7a13b23953e9460e8b4c8a">BearingSensorModel2d</a> = <a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE2d &gt;</td></tr>
<tr class="memdesc:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks bearing detection for 2D state types. <br /></td></tr>
<tr class="separator:aff3ca0663c7a13b23953e9460e8b4c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845217430a786d79ecc03b186504b6b0"><td class="memTemplParams" colspan="2"><a id="a845217430a786d79ecc03b186504b6b0"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:a845217430a786d79ecc03b186504b6b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a845217430a786d79ecc03b186504b6b0">BearingSensorModel3d</a> = <a class="el" href="classbeluga_1_1BearingSensorModel.html">BearingSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE3d &gt;</td></tr>
<tr class="memdesc:a845217430a786d79ecc03b186504b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks bearing detection for 3D state types. <br /></td></tr>
<tr class="separator:a845217430a786d79ecc03b186504b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26305234e807524dd077b13ae21b1dfd"><td class="memItemLeft" align="right" valign="top"><a id="a26305234e807524dd077b13ae21b1dfd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a26305234e807524dd077b13ae21b1dfd">NDTCell2d</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 2, double &gt;</td></tr>
<tr class="memdesc:a26305234e807524dd077b13ae21b1dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2D NDT cell with double representation. <br /></td></tr>
<tr class="separator:a26305234e807524dd077b13ae21b1dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfe19eadacc31d25777adc55929a123"><td class="memItemLeft" align="right" valign="top"><a id="abcfe19eadacc31d25777adc55929a123"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#abcfe19eadacc31d25777adc55929a123">NDTCell2f</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 2, float &gt;</td></tr>
<tr class="memdesc:abcfe19eadacc31d25777adc55929a123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2D NDT cell with float representation. <br /></td></tr>
<tr class="separator:abcfe19eadacc31d25777adc55929a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a678bbddd479148342d699c0a36ed85"><td class="memItemLeft" align="right" valign="top"><a id="a5a678bbddd479148342d699c0a36ed85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5a678bbddd479148342d699c0a36ed85">NDTCell3d</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 3, double &gt;</td></tr>
<tr class="memdesc:a5a678bbddd479148342d699c0a36ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3D NDT cell with double representation. <br /></td></tr>
<tr class="separator:a5a678bbddd479148342d699c0a36ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde3da44e12ce88066174cbdf63484f"><td class="memItemLeft" align="right" valign="top"><a id="aecde3da44e12ce88066174cbdf63484f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aecde3da44e12ce88066174cbdf63484f">NDTCell3f</a> = <a class="el" href="structbeluga_1_1NDTCell.html">NDTCell</a>&lt; 3, float &gt;</td></tr>
<tr class="memdesc:aecde3da44e12ce88066174cbdf63484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3D NDT cell with float representation. <br /></td></tr>
<tr class="separator:aecde3da44e12ce88066174cbdf63484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804a411436199a660eb427f3f664a86"><td class="memTemplParams" colspan="2"><a id="a8804a411436199a660eb427f3f664a86"></a>
template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8804a411436199a660eb427f3f664a86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a8804a411436199a660eb427f3f664a86">BaseRegularGrid2</a> = <a class="el" href="classbeluga_1_1BaseRegularGrid.html">BaseRegularGrid</a>&lt; Derived, 2 &gt;</td></tr>
<tr class="memdesc:a8804a411436199a660eb427f3f664a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2D base regular grid. <br /></td></tr>
<tr class="separator:a8804a411436199a660eb427f3f664a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79ccb7d9229efc84c438c573dcb31e"><td class="memTemplParams" colspan="2"><a id="a9a79ccb7d9229efc84c438c573dcb31e"></a>
template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9a79ccb7d9229efc84c438c573dcb31e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9a79ccb7d9229efc84c438c573dcb31e">BaseRegularGrid3</a> = <a class="el" href="classbeluga_1_1BaseRegularGrid.html">BaseRegularGrid</a>&lt; Derived, 3 &gt;</td></tr>
<tr class="memdesc:a9a79ccb7d9229efc84c438c573dcb31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3D base regular grid. <br /></td></tr>
<tr class="separator:a9a79ccb7d9229efc84c438c573dcb31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6693d4baba7ebd78305bb38f5cb812b2"><td class="memTemplParams" colspan="2"><a id="a6693d4baba7ebd78305bb38f5cb812b2"></a>
template&lt;typename MapType &gt; </td></tr>
<tr class="memitem:a6693d4baba7ebd78305bb38f5cb812b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a6693d4baba7ebd78305bb38f5cb812b2">SparseValueGrid2</a> = <a class="el" href="classbeluga_1_1SparseValueGrid.html">SparseValueGrid</a>&lt; MapType, 2 &gt;</td></tr>
<tr class="memdesc:a6693d4baba7ebd78305bb38f5cb812b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for 2D sparse value grids. <br /></td></tr>
<tr class="separator:a6693d4baba7ebd78305bb38f5cb812b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2de9956d25617ddf8fe45da43882879"><td class="memTemplParams" colspan="2"><a id="aa2de9956d25617ddf8fe45da43882879"></a>
template&lt;typename MapType &gt; </td></tr>
<tr class="memitem:aa2de9956d25617ddf8fe45da43882879"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aa2de9956d25617ddf8fe45da43882879">SparseValueGrid3</a> = <a class="el" href="classbeluga_1_1SparseValueGrid.html">SparseValueGrid</a>&lt; MapType, 3 &gt;</td></tr>
<tr class="memdesc:aa2de9956d25617ddf8fe45da43882879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for 3D sparse value grids. <br /></td></tr>
<tr class="separator:aa2de9956d25617ddf8fe45da43882879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memTemplParams" colspan="2"><a id="abdb1a8b8eea1cc0042f8a6af18dae88b"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#abdb1a8b8eea1cc0042f8a6af18dae88b">LandmarkSensorModel2d</a> = <a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE2d &gt;</td></tr>
<tr class="memdesc:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks for 2D state types. <br /></td></tr>
<tr class="separator:abdb1a8b8eea1cc0042f8a6af18dae88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda37046f0ae0f34cc32d4375a305b39"><td class="memTemplParams" colspan="2"><a id="acda37046f0ae0f34cc32d4375a305b39"></a>
template&lt;class LandmarkMap &gt; </td></tr>
<tr class="memitem:acda37046f0ae0f34cc32d4375a305b39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#acda37046f0ae0f34cc32d4375a305b39">LandmarkSensorModel3d</a> = <a class="el" href="classbeluga_1_1LandmarkSensorModel.html">LandmarkSensorModel</a>&lt; <a class="el" href="classbeluga_1_1LandmarkMap.html">LandmarkMap</a>, Sophus::SE3d &gt;</td></tr>
<tr class="memdesc:acda37046f0ae0f34cc32d4375a305b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor model based on discrete landmarks for 3D state types. <br /></td></tr>
<tr class="separator:acda37046f0ae0f34cc32d4375a305b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfa989fa9330f6fb37201e77ac456c6"><td class="memItemLeft" align="right" valign="top"><a id="a4dfa989fa9330f6fb37201e77ac456c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a4dfa989fa9330f6fb37201e77ac456c6">NDTModelParam2d</a> = <a class="el" href="structbeluga_1_1NDTModelParam.html">NDTModelParam</a>&lt; 2 &gt;</td></tr>
<tr class="memdesc:a4dfa989fa9330f6fb37201e77ac456c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 2d parameters struct for the NDT sensor model. <br /></td></tr>
<tr class="separator:a4dfa989fa9330f6fb37201e77ac456c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d1ffcd87bcc86a50428bd4562441f"><td class="memItemLeft" align="right" valign="top"><a id="a111d1ffcd87bcc86a50428bd4562441f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a111d1ffcd87bcc86a50428bd4562441f">NDTModelParam3d</a> = <a class="el" href="structbeluga_1_1NDTModelParam.html">NDTModelParam</a>&lt; 3 &gt;</td></tr>
<tr class="memdesc:a111d1ffcd87bcc86a50428bd4562441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for a 3d parameters struct for the NDT sensor model. <br /></td></tr>
<tr class="separator:a111d1ffcd87bcc86a50428bd4562441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac55da7142ee7f5d5daec24943726cee"><td class="memTemplParams" colspan="2"><a id="aac55da7142ee7f5d5daec24943726cee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aac55da7142ee7f5d5daec24943726cee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aac55da7142ee7f5d5daec24943726cee">state_t</a> = typename <a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a>&lt; T &gt;::state_type</td></tr>
<tr class="memdesc:aac55da7142ee7f5d5daec24943726cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that returns the state type given a particle type. <br /></td></tr>
<tr class="separator:aac55da7142ee7f5d5daec24943726cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507b3341999e969684415b2bff7fad52"><td class="memTemplParams" colspan="2"><a id="a507b3341999e969684415b2bff7fad52"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a507b3341999e969684415b2bff7fad52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a507b3341999e969684415b2bff7fad52">weight_t</a> = typename <a class="el" href="structbeluga_1_1particle__traits.html">particle_traits</a>&lt; T &gt;::weight_type</td></tr>
<tr class="memdesc:a507b3341999e969684415b2bff7fad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that returns the weight type given a particle type. <br /></td></tr>
<tr class="separator:a507b3341999e969684415b2bff7fad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memTemplParams" colspan="2"><a id="a9a46a50fd14023bdb2fcf0b9aa86434f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a9a46a50fd14023bdb2fcf0b9aa86434f">common_tuple_type_t</a> = typename <a class="el" href="structbeluga_1_1common__tuple__type.html">common_tuple_type</a>&lt; T, U &gt;::type</td></tr>
<tr class="memdesc:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1common__tuple__type.html" title="Meta-function that computes a common tuple type given two tuple-like types T and U.">common_tuple_type</a></code>. <br /></td></tr>
<tr class="separator:a9a46a50fd14023bdb2fcf0b9aa86434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memTemplParams" colspan="2"><a id="a7fe08608971c8c79a6f92a3b5b7ef089"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a7fe08608971c8c79a6f92a3b5b7ef089">tuple_index_t</a> = typename <a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a>&lt; T, TupleLike &gt;::type</td></tr>
<tr class="memdesc:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1tuple__index.html" title="Meta-function that returns the tuple index of the element whose type is T.">tuple_index</a></code>. <br /></td></tr>
<tr class="separator:a7fe08608971c8c79a6f92a3b5b7ef089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memTemplParams" colspan="2"><a id="a5112eb59b4a2ecbb8fa5df915d96c043"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5112eb59b4a2ecbb8fa5df915d96c043">decay_tuple_like_t</a> = typename <a class="el" href="structbeluga_1_1decay__tuple__like.html">decay_tuple_like</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template type alias for <code><a class="el" href="structbeluga_1_1decay__tuple__like.html" title="Meta-function that decays a tuple like type and its members.">decay_tuple_like</a></code>. <br /></td></tr>
<tr class="separator:a5112eb59b4a2ecbb8fa5df915d96c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3fd6c08450af2a226fbb4f87d19736"><td class="memItemLeft" align="right" valign="top"><a id="a3f3fd6c08450af2a226fbb4f87d19736"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3f3fd6c08450af2a226fbb4f87d19736">LandmarkCategory</a> = uint32_t</td></tr>
<tr class="memdesc:a3f3fd6c08450af2a226fbb4f87d19736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent landmark categories. <br /></td></tr>
<tr class="separator:a3f3fd6c08450af2a226fbb4f87d19736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba152cf80db0f1b6d33cf85ecaa77513"><td class="memItemLeft" align="right" valign="top"><a id="aba152cf80db0f1b6d33cf85ecaa77513"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aba152cf80db0f1b6d33cf85ecaa77513">LandmarkPosition3</a> = Eigen::Vector3d</td></tr>
<tr class="memdesc:aba152cf80db0f1b6d33cf85ecaa77513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of a landmark in the world reference frame. <br /></td></tr>
<tr class="separator:aba152cf80db0f1b6d33cf85ecaa77513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db80e6730e2ace4a3d2536de5f90883"><td class="memItemLeft" align="right" valign="top"><a id="a2db80e6730e2ace4a3d2536de5f90883"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a2db80e6730e2ace4a3d2536de5f90883">LandmarkBearing3</a> = Eigen::Vector3d</td></tr>
<tr class="memdesc:a2db80e6730e2ace4a3d2536de5f90883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bearing of a landmark in the sensor reference frame. <br /></td></tr>
<tr class="separator:a2db80e6730e2ace4a3d2536de5f90883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2cc9d22f63d2e373431b4560a7761d"><td class="memItemLeft" align="right" valign="top"><a id="aef2cc9d22f63d2e373431b4560a7761d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aef2cc9d22f63d2e373431b4560a7761d">LandmarkMapBoundaries</a> = Eigen::AlignedBox3d</td></tr>
<tr class="memdesc:aef2cc9d22f63d2e373431b4560a7761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundaries of a landmark map. <br /></td></tr>
<tr class="separator:aef2cc9d22f63d2e373431b4560a7761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af4335f481449a38c85a391979273825c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a> : std::int8_t { <b>kNone</b> = 0x00
, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825caa38f8eba9e293be57492aa18397a225a">kRolloverOnWrite</a> = 0x01
, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825cad2b5d1942cd95644c792b766cebcdfbf">kExtrapolateOnRead</a> = 0x02
, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825ca65589df174cbdb08dcee4d419d84912f">kLayoutReversal</a> = 0x04
 }</td></tr>
<tr class="memdesc:af4335f481449a38c85a391979273825c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature flags for circular arrays.  <a href="namespacebeluga.html#af4335f481449a38c85a391979273825c">More...</a><br /></td></tr>
<tr class="separator:af4335f481449a38c85a391979273825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8701feef2edde9d5688efec1a66045ab"><td class="memItemLeft" align="right" valign="top"><a id="a8701feef2edde9d5688efec1a66045ab"></a>
Sophus::SE2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a8701feef2edde9d5688efec1a66045ab">To2d</a> (const Sophus::SE3d &amp;tf)</td></tr>
<tr class="memdesc:a8701feef2edde9d5688efec1a66045ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a SE3 transform into a SE2 transform, by flattening the Z axis. <br /></td></tr>
<tr class="separator:a8701feef2edde9d5688efec1a66045ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcdce1508dcbf370be7429ab791d89e"><td class="memItemLeft" align="right" valign="top"><a id="a4dcdce1508dcbf370be7429ab791d89e"></a>
Sophus::SE3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a4dcdce1508dcbf370be7429ab791d89e">To3d</a> (const Sophus::SE2d &amp;tf)</td></tr>
<tr class="memdesc:a4dcdce1508dcbf370be7429ab791d89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embed a SE2 transform into 3D space with zero Z translation and only rotation about the Z axis. <br /></td></tr>
<tr class="separator:a4dcdce1508dcbf370be7429ab791d89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d45e8d3d89749501aef47e0fdbb329"><td class="memTemplParams" colspan="2">template&lt;class States , class Weights , class Clusters &gt; </td></tr>
<tr class="memitem:a42d45e8d3d89749501aef47e0fdbb329"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a42d45e8d3d89749501aef47e0fdbb329">estimate_clusters</a> (States &amp;&amp;states, Weights &amp;&amp;weights, Clusters &amp;&amp;clusters)</td></tr>
<tr class="memdesc:a42d45e8d3d89749501aef47e0fdbb329"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each cluster, estimate the mean and covariance of the states that belong to it.  <a href="namespacebeluga.html#a42d45e8d3d89749501aef47e0fdbb329">More...</a><br /></td></tr>
<tr class="separator:a42d45e8d3d89749501aef47e0fdbb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283a211c0e9ec8ad0a71140d11b96b94"><td class="memTemplParams" colspan="2">template&lt;class States , class Weights &gt; </td></tr>
<tr class="memitem:a283a211c0e9ec8ad0a71140d11b96b94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a283a211c0e9ec8ad0a71140d11b96b94">cluster_based_estimate</a> (States &amp;&amp;states, Weights &amp;&amp;weights, <a class="el" href="structbeluga_1_1ParticleClusterizerParam.html">ParticleClusterizerParam</a> parameters={})</td></tr>
<tr class="memdesc:a283a211c0e9ec8ad0a71140d11b96b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a cluster-based estimate from a particle set.  <a href="namespacebeluga.html#a283a211c0e9ec8ad0a71140d11b96b94">More...</a><br /></td></tr>
<tr class="separator:a283a211c0e9ec8ad0a71140d11b96b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408d5ea2b04b0330cefd231bc018e20"><td class="memTemplParams" colspan="2">template&lt;class Range , class DistanceFunction , class NeighborsFunction &gt; </td></tr>
<tr class="memitem:ac408d5ea2b04b0330cefd231bc018e20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ac408d5ea2b04b0330cefd231bc018e20">nearest_obstacle_distance_map</a> (Range &amp;&amp;obstacle_mask, DistanceFunction &amp;&amp;distance_function, NeighborsFunction &amp;&amp;neighbors_function)</td></tr>
<tr class="memdesc:ac408d5ea2b04b0330cefd231bc018e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map where the value of each cell is the distance to the nearest obstacle.  <a href="namespacebeluga.html#ac408d5ea2b04b0330cefd231bc018e20">More...</a><br /></td></tr>
<tr class="separator:ac408d5ea2b04b0330cefd231bc018e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879996e3d483a908a7d5f706ac303b88"><td class="memTemplParams" colspan="2">template&lt;class Range , std::enable_if_t&lt;!is_particle_range_v&lt; Range &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a879996e3d483a908a7d5f706ac303b88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a879996e3d483a908a7d5f706ac303b88">effective_sample_size</a> (Range &amp;&amp;range)</td></tr>
<tr class="memdesc:a879996e3d483a908a7d5f706ac303b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the ESS of a given a range of weights.  <a href="namespacebeluga.html#a879996e3d483a908a7d5f706ac303b88">More...</a><br /></td></tr>
<tr class="separator:a879996e3d483a908a7d5f706ac303b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565300534fff0e7c56b8ece60f9c0eb9"><td class="memTemplParams" colspan="2">template&lt;typename MeanDerived , typename CovarianceDerived , typename TransferFn , typename TransformedT  = std::result_of_t&lt;TransferFn(MeanDerived)&gt;, typename MeanFn  = detail::default_weighted_mean_fn, typename ResidualFn  = std::minus&lt;TransformedT&gt;&gt; </td></tr>
<tr class="memitem:a565300534fff0e7c56b8ece60f9c0eb9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a565300534fff0e7c56b8ece60f9c0eb9">unscented_transform</a> (const Eigen::MatrixBase&lt; MeanDerived &gt; &amp;<a class="el" href="namespacebeluga.html#a90ea4f1947f9abe8d6b00d73269afc02">mean</a>, const Eigen::MatrixBase&lt; CovarianceDerived &gt; &amp;<a class="el" href="namespacebeluga.html#a1e097971cc6bc315081bc0a2b7b587f1">covariance</a>, TransferFn &amp;&amp;transfer_fn, std::optional&lt; typename MeanDerived::Scalar &gt; kappa=std::nullopt, MeanFn mean_fn=<a class="el" href="namespacebeluga.html#a4abc974473c43aaebe8a6a7bea10cd26">default_weighted_mean</a>, ResidualFn residual_fn=std::minus&lt; TransformedT &gt;{})</td></tr>
<tr class="memdesc:a565300534fff0e7c56b8ece60f9c0eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the unscented transform, a mathematical function used to estimate the result of applying a given a possibly nonlinear transformation to a probability distribution that is characterized with mean and covariance. See <a href="https://en.wikipedia.org/wiki/Unscented_transform">https://en.wikipedia.org/wiki/Unscented_transform</a> for more information. Also see <a href="https://arxiv.org/pdf/2104.01958">https://arxiv.org/pdf/2104.01958</a> Equation (5) for more context on sigma points selection.  <a href="namespacebeluga.html#a565300534fff0e7c56b8ece60f9c0eb9">More...</a><br /></td></tr>
<tr class="separator:a565300534fff0e7c56b8ece60f9c0eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223b23ff16126a77c01a5c636bd4f51f"><td class="memItemLeft" align="right" valign="top"><a id="a223b23ff16126a77c01a5c636bd4f51f"></a>
constexpr <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a223b23ff16126a77c01a5c636bd4f51f">operator|</a> (<a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a> lflag, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a> rflag)</td></tr>
<tr class="memdesc:a223b23ff16126a77c01a5c636bd4f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR operator overload to combine two feature flags in a single mask-like flag. <br /></td></tr>
<tr class="separator:a223b23ff16126a77c01a5c636bd4f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02968a6d27e0b7ea3b409d54471da135"><td class="memItemLeft" align="right" valign="top"><a id="a02968a6d27e0b7ea3b409d54471da135"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a02968a6d27e0b7ea3b409d54471da135">operator&amp;</a> (<a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a> mask, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">CircularArrayFeatureFlags</a> flag)</td></tr>
<tr class="memdesc:a02968a6d27e0b7ea3b409d54471da135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND operator overload to check of the presence of a feature <code>flag</code> in a feature <code>mask</code>. <br /></td></tr>
<tr class="separator:a02968a6d27e0b7ea3b409d54471da135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ac1c2126fbec7a8720dc2ea5d06c60dd0">operator&lt;&lt;</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array, T value)</td></tr>
<tr class="memdesc:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient stream operator overload to push a <code>value</code> to a circular <code>array</code>.  <a href="namespacebeluga.html#ac1c2126fbec7a8720dc2ea5d06c60dd0">More...</a><br /></td></tr>
<tr class="separator:ac1c2126fbec7a8720dc2ea5d06c60dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272f96f28f3712285271163e6a6f7684"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a272f96f28f3712285271163e6a6f7684"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a272f96f28f3712285271163e6a6f7684">get</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a272f96f28f3712285271163e6a6f7684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an lvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a272f96f28f3712285271163e6a6f7684">More...</a><br /></td></tr>
<tr class="separator:a272f96f28f3712285271163e6a6f7684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212f42567d6335b60c5e3f631740e36"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a2212f42567d6335b60c5e3f631740e36"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a2212f42567d6335b60c5e3f631740e36">get</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;array) noexcept</td></tr>
<tr class="memdesc:a2212f42567d6335b60c5e3f631740e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an rvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a2212f42567d6335b60c5e3f631740e36">More...</a><br /></td></tr>
<tr class="separator:a2212f42567d6335b60c5e3f631740e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce63db52fec5f22604b6da1c06004e8"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:a3ce63db52fec5f22604b6da1c06004e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3ce63db52fec5f22604b6da1c06004e8">get</a> (const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a3ce63db52fec5f22604b6da1c06004e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant lvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#a3ce63db52fec5f22604b6da1c06004e8">More...</a><br /></td></tr>
<tr class="separator:a3ce63db52fec5f22604b6da1c06004e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbbb813b34da192ec780e769e13254b"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </td></tr>
<tr class="memitem:afbbbb813b34da192ec780e769e13254b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#afbbbb813b34da192ec780e769e13254b">get</a> (const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;array) noexcept</td></tr>
<tr class="memdesc:afbbbb813b34da192ec780e769e13254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant rvalue reference to the ith value in a given <code>array</code>.  <a href="namespacebeluga.html#afbbbb813b34da192ec780e769e13254b">More...</a><br /></td></tr>
<tr class="separator:afbbbb813b34da192ec780e769e13254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35228f88e4dd147943dfd594b25444c5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F, CircularArrayFeatureFlags G&gt; </td></tr>
<tr class="memitem:a35228f88e4dd147943dfd594b25444c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a35228f88e4dd147943dfd594b25444c5">swap</a> (<a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;a, <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, G &gt; &amp;b)</td></tr>
<tr class="memdesc:a35228f88e4dd147943dfd594b25444c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps arrays <code>a</code> and <code>b</code>.  <a href="namespacebeluga.html#a35228f88e4dd147943dfd594b25444c5">More...</a><br /></td></tr>
<tr class="separator:a35228f88e4dd147943dfd594b25444c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memTemplParams" colspan="2"><a id="a5715c8a34b7699f5309e6ffc44202cc2"></a>
template&lt;class I , class S , typename  = std::enable_if_t&lt;ranges::input_iterator&lt;I&gt; &amp;&amp; ranges::input_iterator&lt;S&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a5715c8a34b7699f5309e6ffc44202cc2">TupleVector</a> (I, S) -&gt; <a class="el" href="classbeluga_1_1TupleVector.html">TupleVector</a>&lt; <a class="el" href="namespacebeluga.html#a5112eb59b4a2ecbb8fa5df915d96c043">decay_tuple_like_t</a>&lt; ranges::iter_value_t&lt; I &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a5715c8a34b7699f5309e6ffc44202cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide to construct from iterators. <br /></td></tr>
<tr class="separator:a5715c8a34b7699f5309e6ffc44202cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3a16c1b4130d54628383d4dac50b1"><td class="memTemplParams" colspan="2"><a id="a13b3a16c1b4130d54628383d4dac50b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a13b3a16c1b4130d54628383d4dac50b1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a13b3a16c1b4130d54628383d4dac50b1">MultivariateNormalDistribution</a> (const T &amp;, const typename <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a>&lt; T &gt;::covariance_type &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateNormalDistribution.html">MultivariateNormalDistribution</a>&lt; typename <a class="el" href="structbeluga_1_1multivariate__distribution__traits.html">multivariate_distribution_traits</a>&lt; T &gt;::result_type &gt;</td></tr>
<tr class="memdesc:a13b3a16c1b4130d54628383d4dac50b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide to deduce the correct result type. <br /></td></tr>
<tr class="separator:a13b3a16c1b4130d54628383d4dac50b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43b795348b23ec8134a8bf51dd5068b"><td class="memItemLeft" align="right" valign="top"><a id="aa43b795348b23ec8134a8bf51dd5068b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aa43b795348b23ec8134a8bf51dd5068b">MultivariateUniformDistribution</a> (const Eigen::AlignedBox2d &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE2d, Eigen::AlignedBox2d &gt;</td></tr>
<tr class="memdesc:aa43b795348b23ec8134a8bf51dd5068b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for bounding regions in SE2 space. <br /></td></tr>
<tr class="separator:aa43b795348b23ec8134a8bf51dd5068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507ebc0464246bdf725c985bff3dce6"><td class="memItemLeft" align="right" valign="top"><a id="ac507ebc0464246bdf725c985bff3dce6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ac507ebc0464246bdf725c985bff3dce6">MultivariateUniformDistribution</a> (const Eigen::AlignedBox3d &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE3d, Eigen::AlignedBox3d &gt;</td></tr>
<tr class="memdesc:ac507ebc0464246bdf725c985bff3dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for bounding regions in SE3 space. <br /></td></tr>
<tr class="separator:ac507ebc0464246bdf725c985bff3dce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68b075a1af1561921788425e0fd656"><td class="memTemplParams" colspan="2"><a id="a3a68b075a1af1561921788425e0fd656"></a>
template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a3a68b075a1af1561921788425e0fd656"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a3a68b075a1af1561921788425e0fd656">MultivariateUniformDistribution</a> (const <a class="el" href="classbeluga_1_1BaseOccupancyGrid2.html">BaseOccupancyGrid2</a>&lt; Derived &gt; &amp;) -&gt; <a class="el" href="classbeluga_1_1MultivariateUniformDistribution.html">MultivariateUniformDistribution</a>&lt; Sophus::SE2d, Derived &gt;</td></tr>
<tr class="memdesc:a3a68b075a1af1561921788425e0fd656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for 2D occupancy grids. <br /></td></tr>
<tr class="separator:a3a68b075a1af1561921788425e0fd656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecd4522d48bf1f7b59320b62b024102"><td class="memTemplParams" colspan="2"><a id="afecd4522d48bf1f7b59320b62b024102"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:afecd4522d48bf1f7b59320b62b024102"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#afecd4522d48bf1f7b59320b62b024102">element</a> (TupleLike &amp;&amp;tuple) noexcept</td></tr>
<tr class="memdesc:afecd4522d48bf1f7b59320b62b024102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element of a tuple like object whose type is T (or a possibly const reference to T). <br /></td></tr>
<tr class="separator:afecd4522d48bf1f7b59320b62b024102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854c705ccfa38ad771b16bd4ee39d228"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a854c705ccfa38ad771b16bd4ee39d228"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a854c705ccfa38ad771b16bd4ee39d228">forward_like</a> (U &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a854c705ccfa38ad771b16bd4ee39d228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a value which has similar properties to <code>T&amp;&amp;</code>.  <a href="namespacebeluga.html#a854c705ccfa38ad771b16bd4ee39d228">More...</a><br /></td></tr>
<tr class="separator:a854c705ccfa38ad771b16bd4ee39d228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f0063a224fbb53815706d549ccd01d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a33f0063a224fbb53815706d549ccd01d">kld_condition</a> (std::size_t min, double epsilon, double z=beluga::detail::kDefaultKldZ)</td></tr>
<tr class="memdesc:a33f0063a224fbb53815706d549ccd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that verifies if the KLD condition is being satisfied.  <a href="namespacebeluga.html#a33f0063a224fbb53815706d549ccd01d">More...</a><br /></td></tr>
<tr class="separator:a33f0063a224fbb53815706d549ccd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a90ea4f1947f9abe8d6b00d73269afc02"><td class="memItemLeft" align="right" valign="top">constexpr detail::mean_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a90ea4f1947f9abe8d6b00d73269afc02">mean</a></td></tr>
<tr class="memdesc:a90ea4f1947f9abe8d6b00d73269afc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the weighted mean (or average) of a range of values.  <a href="namespacebeluga.html#a90ea4f1947f9abe8d6b00d73269afc02">More...</a><br /></td></tr>
<tr class="separator:a90ea4f1947f9abe8d6b00d73269afc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e097971cc6bc315081bc0a2b7b587f1"><td class="memItemLeft" align="right" valign="top">constexpr detail::covariance_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a1e097971cc6bc315081bc0a2b7b587f1">covariance</a></td></tr>
<tr class="memdesc:a1e097971cc6bc315081bc0a2b7b587f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the weighted covariance of a range of values.  <a href="namespacebeluga.html#a1e097971cc6bc315081bc0a2b7b587f1">More...</a><br /></td></tr>
<tr class="separator:a1e097971cc6bc315081bc0a2b7b587f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaef1243abc9e2f60cd62d0e625a6de"><td class="memItemLeft" align="right" valign="top">constexpr detail::estimate_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#adcaef1243abc9e2f60cd62d0e625a6de">estimate</a></td></tr>
<tr class="memdesc:adcaef1243abc9e2f60cd62d0e625a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the estimate (mean and covariance) of a range of values.  <a href="namespacebeluga.html#adcaef1243abc9e2f60cd62d0e625a6de">More...</a><br /></td></tr>
<tr class="separator:adcaef1243abc9e2f60cd62d0e625a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abc974473c43aaebe8a6a7bea10cd26"><td class="memItemLeft" align="right" valign="top"><a id="a4abc974473c43aaebe8a6a7bea10cd26"></a>
constexpr <a class="el" href="structbeluga_1_1detail_1_1default__weighted__mean__fn.html">detail::default_weighted_mean_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a4abc974473c43aaebe8a6a7bea10cd26">default_weighted_mean</a></td></tr>
<tr class="memdesc:a4abc974473c43aaebe8a6a7bea10cd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object for computing a euclidean weighted mean of a vector of elements. <br /></td></tr>
<tr class="separator:a4abc974473c43aaebe8a6a7bea10cd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="memItemLeft" align="right" valign="top"><a id="aff8f47028f19c4ca9fbc4ef0473c8fdd"></a>
constexpr detail::make_policy_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff8f47028f19c4ca9fbc4ef0473c8fdd">make_policy</a></td></tr>
<tr class="memdesc:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make policy function objects. <br /></td></tr>
<tr class="separator:aff8f47028f19c4ca9fbc4ef0473c8fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706431bba3d6cfb1ee0690221f3a9af9"><td class="memItemLeft" align="right" valign="top"><a id="a706431bba3d6cfb1ee0690221f3a9af9"></a>
constexpr <a class="el" href="structbeluga_1_1state__detail_1_1state__fn.html">state_detail::state_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a706431bba3d6cfb1ee0690221f3a9af9">state</a></td></tr>
<tr class="memdesc:a706431bba3d6cfb1ee0690221f3a9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for accessing the <code>state</code> of a particle. <br /></td></tr>
<tr class="separator:a706431bba3d6cfb1ee0690221f3a9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80abdff6d85df8ef392ca252ed8588c1"><td class="memItemLeft" align="right" valign="top"><a id="a80abdff6d85df8ef392ca252ed8588c1"></a>
constexpr <a class="el" href="structbeluga_1_1weight__detail_1_1weight__fn.html">weight_detail::weight_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a80abdff6d85df8ef392ca252ed8588c1">weight</a></td></tr>
<tr class="memdesc:a80abdff6d85df8ef392ca252ed8588c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for accessing the <code>weight</code> of a particle. <br /></td></tr>
<tr class="separator:a80abdff6d85df8ef392ca252ed8588c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ab9d2dd17389ef5260b264329a463f"><td class="memTemplParams" colspan="2">template&lt;class Particle &gt; </td></tr>
<tr class="memitem:a30ab9d2dd17389ef5260b264329a463f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structbeluga_1_1detail_1_1make__from__state__fn.html">detail::make_from_state_fn</a>&lt; Particle &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a30ab9d2dd17389ef5260b264329a463f">make_from_state</a></td></tr>
<tr class="memdesc:a30ab9d2dd17389ef5260b264329a463f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to create a particle from a given state.  <a href="namespacebeluga.html#a30ab9d2dd17389ef5260b264329a463f">More...</a><br /></td></tr>
<tr class="separator:a30ab9d2dd17389ef5260b264329a463f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df71946142fa16a5d42d198c2ca3ec"><td class="memTemplParams" colspan="2"><a id="a57df71946142fa16a5d42d198c2ca3ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a57df71946142fa16a5d42d198c2ca3ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a57df71946142fa16a5d42d198c2ca3ec">is_tuple_like_v</a> = <a class="el" href="structbeluga_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a57df71946142fa16a5d42d198c2ca3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1is__tuple__like.html" title="Meta-function that returns true if T is a tuple-like type.">is_tuple_like</a></code>. <br /></td></tr>
<tr class="separator:a57df71946142fa16a5d42d198c2ca3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb9e2396ce921ef923c703ba45f258"><td class="memTemplParams" colspan="2"><a id="ab6fb9e2396ce921ef923c703ba45f258"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab6fb9e2396ce921ef923c703ba45f258"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#ab6fb9e2396ce921ef923c703ba45f258">has_common_tuple_type_v</a> = <a class="el" href="structbeluga_1_1has__common__tuple__type.html">has_common_tuple_type</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:ab6fb9e2396ce921ef923c703ba45f258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1has__common__tuple__type.html" title="Meta-function that checks for the existence of a common tuple type.">has_common_tuple_type</a></code>. <br /></td></tr>
<tr class="separator:ab6fb9e2396ce921ef923c703ba45f258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528b7d8d6f614c786f40275567ff5127"><td class="memTemplParams" colspan="2"><a id="a528b7d8d6f614c786f40275567ff5127"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:a528b7d8d6f614c786f40275567ff5127"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#a528b7d8d6f614c786f40275567ff5127">tuple_index_v</a> = <a class="el" href="structbeluga_1_1tuple__index.html">tuple_index</a>&lt;T, TupleLike&gt;::value</td></tr>
<tr class="memdesc:a528b7d8d6f614c786f40275567ff5127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1tuple__index.html" title="Meta-function that returns the tuple index of the element whose type is T.">tuple_index</a></code>. <br /></td></tr>
<tr class="separator:a528b7d8d6f614c786f40275567ff5127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6cba96ed18281cbfbb37187289f58b"><td class="memTemplParams" colspan="2"><a id="aff6cba96ed18281cbfbb37187289f58b"></a>
template&lt;class T , class TupleLike &gt; </td></tr>
<tr class="memitem:aff6cba96ed18281cbfbb37187289f58b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeluga.html#aff6cba96ed18281cbfbb37187289f58b">has_single_element_v</a> = <a class="el" href="structbeluga_1_1has__single__element.html">has_single_element</a>&lt;T, TupleLike&gt;::value</td></tr>
<tr class="memdesc:aff6cba96ed18281cbfbb37187289f58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable for <code><a class="el" href="structbeluga_1_1has__single__element.html" title="Meta-function that returns true if there is a single element of type T in the tuple-like type.">has_single_element</a></code>. <br /></td></tr>
<tr class="separator:aff6cba96ed18281cbfbb37187289f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main Beluga namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a04edda41f9d87d101fa8dd0c7f965743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04edda41f9d87d101fa8dd0c7f965743">&#9670;&nbsp;</a></span>RollingWindow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebeluga.html#a04edda41f9d87d101fa8dd0c7f965743">beluga::RollingWindow</a> = typedef <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825caa38f8eba9e293be57492aa18397a225a">CircularArrayFeatureFlags::kRolloverOnWrite</a> | <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825cad2b5d1942cd95644c792b766cebcdfbf">CircularArrayFeatureFlags::kExtrapolateOnRead</a> | <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825ca65589df174cbdb08dcee4d419d84912f">CircularArrayFeatureFlags::kLayoutReversal</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient type alias for a circular array that behaves like a rolling window. </p>
<p>A rolling window automatically overwrites older values, it extrapolates its last value to always seem full, and it is accessed by the front. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af4335f481449a38c85a391979273825c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4335f481449a38c85a391979273825c">&#9670;&nbsp;</a></span>CircularArrayFeatureFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacebeluga.html#af4335f481449a38c85a391979273825c">beluga::CircularArrayFeatureFlags</a> : std::int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Feature flags for circular arrays. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af4335f481449a38c85a391979273825caa38f8eba9e293be57492aa18397a225a"></a>kRolloverOnWrite&#160;</td><td class="fielddoc"><p>! If enabled, older values in the array are overwritten by newer values if the array has reached its maximum size already. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4335f481449a38c85a391979273825cad2b5d1942cd95644c792b766cebcdfbf"></a>kExtrapolateOnRead&#160;</td><td class="fielddoc"><p>! If enabled, the back value is extrapolated for constant accesses up to the array maximum size. </p>
</td></tr>
<tr><td class="fieldname"><a id="af4335f481449a38c85a391979273825ca65589df174cbdb08dcee4d419d84912f"></a>kLayoutReversal&#160;</td><td class="fielddoc"><p>! If enabled, the circular array memory layout is reversed so that values can be pushed to the front rather than the back of the array. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a283a211c0e9ec8ad0a71140d11b96b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283a211c0e9ec8ad0a71140d11b96b94">&#9670;&nbsp;</a></span>cluster_based_estimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class States , class Weights &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::cluster_based_estimate </td>
          <td>(</td>
          <td class="paramtype">States &amp;&amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Weights &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbeluga_1_1ParticleClusterizerParam.html">ParticleClusterizerParam</a>&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a cluster-based estimate from a particle set. </p>
<p>Particles are grouped into clusters around local maxima. The state mean and covariance of the cluster with the highest total weight is returned. If no clusters are found, the overall mean and covariance of the particles are calculated and returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">States</td><td>Range type of the states. </td></tr>
    <tr><td class="paramname">Weights</td><td>Range type of the weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>Range containing the states of the particles. </td></tr>
    <tr><td class="paramname">weights</td><td>Range containing the weights of the particles. </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameters for the particle clusterizer (optional). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of the state mean and covariance of the cluster with the highest total weight. </dd></dl>

</div>
</div>
<a id="a879996e3d483a908a7d5f706ac303b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879996e3d483a908a7d5f706ac303b88">&#9670;&nbsp;</a></span>effective_sample_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , std::enable_if_t&lt;!is_particle_range_v&lt; Range &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::effective_sample_size </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the ESS of a given a range of weights. </p>
<p>Overload for particle ranges.</p>
<p>The effective sample size (ESS) is a figure of merit for importance sampling methods' output. It characterizes how well the target posterior distribution is approximated (as it is proportional to the efficiency of distribution parameter estimators, <a class="el" href="citelist.html#CITEREF_kong1994sequentialimputations">[3]</a>, section 4.1). It can be interpreted as the number of samples effectively approximating the distribution, and thus comparing with the total number of samples makes for a good mechanism to detect and react to performance degradation e.g. triggering a resample when the ESS falls below a fraction of the total number of samples.</p>
<p>The algorithm is based on <a class="el" href="citelist.html#CITEREF_grisetti2007selectiveresampling">[2]</a>, according to the description given in <a class="el" href="citelist.html#CITEREF_tiacheng2015resamplingmethods">[4]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/forward_range">forward range</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of weights. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d45e8d3d89749501aef47e0fdbb329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d45e8d3d89749501aef47e0fdbb329">&#9670;&nbsp;</a></span>estimate_clusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class States , class Weights , class Clusters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::estimate_clusters </td>
          <td>(</td>
          <td class="paramtype">States &amp;&amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Weights &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clusters &amp;&amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each cluster, estimate the mean and covariance of the states that belong to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">States</td><td>Range type of the states. </td></tr>
    <tr><td class="paramname">Weights</td><td>Range type of the weights. </td></tr>
    <tr><td class="paramname">Hashes</td><td>Range type of the hashes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>Range containing the states of the particles. </td></tr>
    <tr><td class="paramname">weights</td><td>Range containing the weights of the particles. </td></tr>
    <tr><td class="paramname">clusters</td><td>Cluster ids of the particles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements, containing the weight, mean and covariance of each cluster, in no particular order. </dd></dl>
<p>Convenient factory method to pass to <code>zip_with</code>.</p>

</div>
</div>
<a id="a854c705ccfa38ad771b16bd4ee39d228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854c705ccfa38ad771b16bd4ee39d228">&#9670;&nbsp;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto&amp;&amp; beluga::forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to a value which has similar properties to <code>T&amp;&amp;</code>. </p>
<p>Implementation taken from <a href="https://en.cppreference.com/w/cpp/utility/forward_like">https://en.cppreference.com/w/cpp/utility/forward_like</a> since this feature is only available starting with C++23.</p>
<p>The program is ill-formed if <code>T&amp;&amp;</code> is not a valid type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type from which to take the properties. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value that needs to be forwarded like type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to value of the determined type. </dd></dl>

</div>
</div>
<a id="a2212f42567d6335b60c5e3f631740e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212f42567d6335b60c5e3f631740e36">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an rvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a272f96f28f3712285271163e6a6f7684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272f96f28f3712285271163e6a6f7684">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an lvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="afbbbb813b34da192ec780e769e13254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbbb813b34da192ec780e769e13254b">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp;&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant rvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a3ce63db52fec5f22604b6da1c06004e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce63db52fec5f22604b6da1c06004e8">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; beluga::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant lvalue reference to the ith value in a given <code>array</code>. </p>
<p>This is an <code>std::get</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a33f0063a224fbb53815706d549ccd01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f0063a224fbb53815706d549ccd01d">&#9670;&nbsp;</a></span>kld_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::kld_condition </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em> = <code>beluga::detail::kDefaultKldZ</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that verifies if the KLD condition is being satisfied. </p>
<p>The callable object will compute the minimum number of samples based on a Kullback-Leibler distance epsilon between the maximum likelihood estimate and the true distribution. <br  />
Z is the upper standard normal quantile for P, where P is the probability that the error in the estimated distribution will be less than epsilon.</p>
<p>Here are some examples: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">P   </th><th class="markdownTableHeadNone">Z    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.900   </td><td class="markdownTableBodyNone">1.28155156327703    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.950   </td><td class="markdownTableBodyNone">1.64485362793663    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.990   </td><td class="markdownTableBodyNone">2.32634787735669    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.999   </td><td class="markdownTableBodyNone">3.09023224677087   </td></tr>
</table>
<p>If the computed value is less than what the min argument specifies, then min will be returned.</p>
<p>See KLD-Sampling: Adaptive Particle Filters <a class="el" href="citelist.html#CITEREF_fox2001adaptivekldsampling">[1]</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number of particles that the callable object will return. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum distance epsilon between the maximum likelihood estimate and the true distrubution. </td></tr>
    <tr><td class="paramname">z</td><td>Upper standard normal quantile for the probability that the error in the estimated distribution is less than epsilon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype <code>(std::size_t hash) -&gt; bool</code>. <code>hash</code> is the spatial hash of the particle being added. <br  />
 The returned callable object is stateful, tracking the total number of particles and the particle clusters based on the spatial hash. <br  />
 The return value of the callable will be false when the number of particles is more than the minimum and the KLD condition is satisfied, if not it will be true. <br  />
 i.e. A return value of true means that you need to keep sampling to satisfy the condition. </dd></dl>

</div>
</div>
<a id="ac408d5ea2b04b0330cefd231bc018e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac408d5ea2b04b0330cefd231bc018e20">&#9670;&nbsp;</a></span>nearest_obstacle_distance_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class DistanceFunction , class NeighborsFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::nearest_obstacle_distance_map </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>obstacle_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistanceFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>distance_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighborsFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>neighbors_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map where the value of each cell is the distance to the nearest obstacle. </p>
<p>The algorithm uses O(N) time and memory, where <code>N=ranges::size(obstacle_map)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/sized_range">sized range</a>. Its value type must be bool. </td></tr>
    <tr><td class="paramname">DistanceFunction</td><td>A callable type, its prototype must be (std::size_t, std::size_t) -&gt; DistanceType. DistanceType must be an scalar type. </td></tr>
    <tr><td class="paramname">NeighborsFunction</td><td>A callabe type, its prototype must be (std::size_t) -&gt; NeighborsT, where NeighborsT is a <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> with value type std::size_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obstacle_mask</td><td>A mask that represents obstacles in an environment. If the value of a cell is True, the cell has an obstacle. </td></tr>
    <tr><td class="paramname">distance_function</td><td>Given the indexes of two cells in the map i and j, obstacle_map(i, j) must return the distance between the two cells. </td></tr>
    <tr><td class="paramname">neighbors_function</td><td>Given the index i of one cell in the map, neighbors_function(i) returns the cell indexes of neighbor cells in the obstacle map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each cell value is the distance to the nearest object. </dd></dl>

</div>
</div>
<a id="ac1c2126fbec7a8720dc2ea5d06c60dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2126fbec7a8720dc2ea5d06c60dd0">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt;T, N, F&gt;&amp; beluga::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient stream operator overload to push a <code>value</code> to a circular <code>array</code>. </p>
<p>Functionally equivalent to a push_back() (or push_front() if the layout reversal feature is enabled). </p>

</div>
</div>
<a id="a35228f88e4dd147943dfd594b25444c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35228f88e4dd147943dfd594b25444c5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, CircularArrayFeatureFlags F, CircularArrayFeatureFlags G&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void beluga::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbeluga_1_1CircularArray.html">CircularArray</a>&lt; T, N, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps arrays <code>a</code> and <code>b</code>. </p>
<p>This is an <code>std::swap</code> overload that relies on argument-dependent lookup (ADL). </p>

</div>
</div>
<a id="a565300534fff0e7c56b8ece60f9c0eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565300534fff0e7c56b8ece60f9c0eb9">&#9670;&nbsp;</a></span>unscented_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeanDerived , typename CovarianceDerived , typename TransferFn , typename TransformedT  = std::result_of_t&lt;TransferFn(MeanDerived)&gt;, typename MeanFn  = detail::default_weighted_mean_fn, typename ResidualFn  = std::minus&lt;TransformedT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::unscented_transform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; MeanDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; CovarianceDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>transfer_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; typename MeanDerived::Scalar &gt;&#160;</td>
          <td class="paramname"><em>kappa</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeanFn&#160;</td>
          <td class="paramname"><em>mean_fn</em> = <code><a class="el" href="namespacebeluga.html#a4abc974473c43aaebe8a6a7bea10cd26">default_weighted_mean</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResidualFn&#160;</td>
          <td class="paramname"><em>residual_fn</em> = <code>std::minus&lt;TransformedT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the unscented transform, a mathematical function used to estimate the result of applying a given a possibly nonlinear transformation to a probability distribution that is characterized with mean and covariance. See <a href="https://en.wikipedia.org/wiki/Unscented_transform">https://en.wikipedia.org/wiki/Unscented_transform</a> for more information. Also see <a href="https://arxiv.org/pdf/2104.01958">https://arxiv.org/pdf/2104.01958</a> Equation (5) for more context on sigma points selection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeanDerived</td><td>Concrete Eigen dense type used for the mean. </td></tr>
    <tr><td class="paramname">CovarianceDerived</td><td>Concrete Eigen dense type used for the covariance. </td></tr>
    <tr><td class="paramname">TransferFn</td><td>Callable that maps a vector from input space to output space. Possibly non-linear. </td></tr>
    <tr><td class="paramname">TransformedT</td><td>State representing the output space. Deduced from the transfer function. </td></tr>
    <tr><td class="paramname">MeanFn</td><td>Callable that converts a vector of elements in the output space, and weights, to its mean in the output space. </td></tr>
    <tr><td class="paramname">ResidualFn</td><td>Callable that computes a residual given two elements in the output space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean in the input space. </td></tr>
    <tr><td class="paramname">covariance</td><td>Covariance in the input space. </td></tr>
    <tr><td class="paramname">transfer_fn</td><td>Callable that converts a* vector from input space to output space. </td></tr>
    <tr><td class="paramname">kappa</td><td>Parameter used for sigma points selection. A sensible default will be used if not provided. </td></tr>
    <tr><td class="paramname">mean_fn</td><td>Callable that converts a vector of elements in the output space, and weights, to its mean in the output space. A sensible default is provided for the trivial (euclidian) case. </td></tr>
    <tr><td class="paramname">residual_fn</td><td>Callable that computes a residual given two elements in the output space.. A sensible default is provided for the trivial (euclidian) case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing (mean, estimate) for the output space. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e097971cc6bc315081bc0a2b7b587f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e097971cc6bc315081bc0a2b7b587f1">&#9670;&nbsp;</a></span>covariance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::covariance_fn beluga::covariance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the weighted covariance of a range of values. </p>
<p>The inputs are a range of values, a range of corresponding weights, the pre-computed mean, and an optional projection function to convert to the right value-type.</p>
<p>It supports floating-point numbers, vectors, and Lie group elements like SE2 and SE3.</p>
<p>For Lie group elements, the function computes covariance in the tangent space, representing the uncertainty of poses on the Lie manifold. Users may perform the appropriate conversions to get the covariance matrix into their parametrization of interest.</p>
<p>The weights are assumed to already be normalized. Non-normalized weights will yield incorrect results. </p>

</div>
</div>
<a id="adcaef1243abc9e2f60cd62d0e625a6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaef1243abc9e2f60cd62d0e625a6de">&#9670;&nbsp;</a></span>estimate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::estimate_fn beluga::estimate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the estimate (mean and covariance) of a range of values. </p>
<p>The inputs are a range of values and a range of corresponding weights. It supports floating-point numbers, vectors, and Lie group elements like SE2 and SE3.</p>
<p>The function does not assume that the input weights are normalized. It normalizes the weights while iterating, which might have a performance impact. Specifically, the function has to iterate over the weights multiple times (e.g., once to compute the mean, and again to compute the covariance). The normalization factor is computed once, but division for normalizing the weights is performed each time a weight is accessed. </p>

</div>
</div>
<a id="a30ab9d2dd17389ef5260b264329a463f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ab9d2dd17389ef5260b264329a463f">&#9670;&nbsp;</a></span>make_from_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structbeluga_1_1detail_1_1make__from__state__fn.html">detail::make_from_state_fn</a>&lt;Particle&gt; beluga::make_from_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function object to create a particle from a given state. </p>
<p>Takes a state and returns a new particle with that state. The new particle is given a weight of 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle</td><td>The particle type to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ea4f1947f9abe8d6b00d73269afc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ea4f1947f9abe8d6b00d73269afc02">&#9670;&nbsp;</a></span>mean</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr detail::mean_fn beluga::mean</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the weighted mean (or average) of a range of values. </p>
<p>The inputs are a range of values, a range of corresponding weights, and an optional projection function to convert to the right value-type.</p>
<p>It supports floating-point numbers, vectors, quaternions, and Lie group elements like SE2 and SE3.</p>
<p>The weights are assumed to already be normalized. Non-normalized weights will yield incorrect results. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
</div>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Ekumen Research
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022-2024 Ekumen, Inc..
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
  Last updated on &#39;Fri Dec 20 16:03:38 2024 -0300, b2748e4&#39;.
  <br/>
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>