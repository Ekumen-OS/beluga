// Copyright 2022 Ekumen, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef BELUGA_MOTION_OMNI_DRIVE_MODEL_HPP
#define BELUGA_MOTION_OMNI_DRIVE_MODEL_HPP

#include <optional>
#include <random>
#include <shared_mutex>

#include <sophus/se2.hpp>
#include <sophus/so2.hpp>

/**
 * \file
 * \brief Implementation of a omnidirectional drive odometry motion model.
 */

namespace beluga {

/// Parameters to construct a OmniDriveModel instance.
/**
 * \TODO(olmerg) put a cite
 */
struct OmniDriveModelParam {
  /// Rotational noise from rotation
  /**
   * How much rotational noise is generated by the relative rotation between the last two odometry updates.
   * Also known as `alpha1`.
   */
  double rotation_noise_from_rotation;
  /// Rotational noise from translation
  /**
   * How much rotational noise is generated by the relative translation between the last two odometry updates.
   * Also known as `alpha2`.
   */
  double rotation_noise_from_translation;
  /// Translational noise from translation
  /**
   * How much translational in longitudinal noise is generated by the relative translation between
   * the last two odometry updates.
   * Also known as `alpha3`.
   */
  double translation_noise_from_translation;
  /// Translational noise from rotation
  /**
   * How much translational noise is generated by the relative rotation between the last two odometry updates.
   * Also known as `alpha4`.
   */
  double translation_noise_from_rotation;
  /// Translational noise from translation
  /**
   * How much translational noise in sideway is generated by the relative translation between the last two
   * odometry updates.
   * Also known as `alpha5`.
   */
  double translation_sideway_noise_from_translation;
};

/// Sampled odometry model for a omnidirectional drive.
/**
 * \tparam Mixin The mixed-in type.
 */
template <class Mixin>
class OmniDriveModel : public Mixin {
 public:
  /// Update type of the motion model, same as the state_type in the odometry model.
  using update_type = Sophus::SE2d;
  /// State type of a particle.
  using state_type = Sophus::SE2d;

  /// Parameter type that the constructor uses to configure the motion model.
  using param_type = OmniDriveModelParam;

  /// Constructs a OmniDriveModel instance.
  /**
   * \tparam ...Args Arguments types for the remaining mixin constructors.
   * \param params Parameters to configure this instance.
   *  See beluga::OmniDriveModelParam for details.
   * \param ...args arguments that are not used by this part of the mixin, but by others.
   */
  template <class... Args>
  explicit OmniDriveModel(const param_type& params, Args&&... args)
      : Mixin(std::forward<Args>(args)...), params_{params} {}

  /// Applies the last update to the particle state given.
  /**
   * \param state The particle state to apply the motion to.
   * \return The updated particle state.
   */
  [[nodiscard]] state_type apply_motion(const state_type& state) const {
    static thread_local auto generator = std::mt19937{std::random_device()()};
    static thread_local auto distribution = std::normal_distribution<double>{};
    const auto lock = std::shared_lock<std::shared_mutex>{params_mutex_};
    const auto rotation_angle = Sophus::SO2d{distribution(generator, rotation_params_)} * state.so2();
    const auto translation = Eigen::Vector2d{
        distribution(generator, translation_params_), distribution(generator, translation_sideway_params_)};
    const auto bearing_rotation = delta_bearing_fix_ * state.so2();
    // TODO(olmerg) make this with vector2d and so2d t =state_t R*t is the idea
    const auto local = Sophus::SE2d{0.0, state.translation()} *
                       Sophus::SE2d{bearing_rotation, Eigen::Vector2d{0.0, 0.0}} * Sophus::SE2d{0.0, translation};
    return Sophus::SE2d{rotation_angle, local.translation()};
  }

  /// Updates the motion model.
  /**
   * This will not update particles.
   * That is done by the particle filter using the apply_motion() method
   * provided by this class.
   *
   * \param pose Last odometry udpate.
   */
  void update_motion(const update_type& pose) {
    if (last_pose_) {
      const auto translation = pose.translation() - last_pose_.value().translation();
      const double distance = translation.norm();
      const double distance_variance = distance * distance;

      const auto& previous_orientation = last_pose_.value().so2();
      const auto& current_orientation = pose.so2();
      const auto rotation = current_orientation * previous_orientation.inverse();

      {
        const auto lock = std::lock_guard<std::shared_mutex>{params_mutex_};
        delta_bearing_fix_ =
            Sophus::SO2d{std::atan2(translation.y(), translation.x())} * previous_orientation.inverse();
        const double rotation_variance_ = rotation_variance(rotation);
        rotation_params_ = DistributionParam{
            rotation.log(), std::sqrt(
                                params_.rotation_noise_from_rotation * rotation_variance_ +
                                params_.rotation_noise_from_translation * distance_variance)};
        translation_params_ = DistributionParam{
            distance, std::sqrt(
                          params_.translation_noise_from_translation * distance_variance +
                          params_.translation_noise_from_rotation * rotation_variance_)};
        translation_sideway_params_ = DistributionParam{
            -0.0, std::sqrt(
                      params_.translation_sideway_noise_from_translation * distance_variance +
                      params_.translation_noise_from_rotation * rotation_variance_)};
      }
    }
    last_pose_ = pose;
  }

 private:
  using DistributionParam = typename std::normal_distribution<double>::param_type;

  OmniDriveModelParam params_;
  std::optional<Sophus::SE2d> last_pose_;

  DistributionParam rotation_params_{0.0, 0.0};
  DistributionParam translation_sideway_params_{0.0, 0.0};
  DistributionParam translation_params_{0.0, 0.0};
  Sophus::SO2d delta_bearing_fix_;
  mutable std::shared_mutex params_mutex_;

  static double rotation_variance(const Sophus::SO2d& rotation) {
    // Treat backward and forward motion symmetrically for the noise models.
    const auto flipped_rotation = rotation * Sophus::SO2d{Sophus::Constants<double>::pi()};
    const auto delta = std::min(std::abs(rotation.log()), std::abs(flipped_rotation.log()));
    return delta * delta;
  }
};

}  // namespace beluga

#endif
