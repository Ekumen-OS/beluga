<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beluga: /home/runner/work/beluga/beluga/repository/beluga/include/beluga/algorithm/sampling.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beluga
   </div>
   <div id="projectbrief">An extensible Monte Carlo based localization library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_1ad523cfdb7a3d7d09cddf672d6cd478.html">beluga</a></li><li class="navelem"><a class="el" href="dir_634c6b228f937c8a89fa81bc2f240134.html">algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sampling.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of algorithms related to generation, sampling and resampling of particles.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;<a class="el" href="exponential__filter_8hpp_source.html">beluga/algorithm/exponential_filter.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="spatial__hash_8hpp_source.html">beluga/spatial_hash.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="type__traits_8hpp_source.html">beluga/type_traits.hpp</a>&gt;</code><br />
<code>#include &lt;range/v3/view/generate.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take_exactly.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take_while.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/transform.hpp&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sampling.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="sampling_8hpp__incl.png" border="0" usemap="#a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp" alt=""/></div>
<map name="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp" id="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp">
<area shape="rect" title="Implementation of algorithms related to generation, sampling and resampling of particles." alt="" coords="1113,5,1306,76"/>
<area shape="rect" title=" " alt="" coords="218,131,305,158"/>
<area shape="rect" title=" " alt="" coords="5,221,64,247"/>
<area shape="rect" title=" " alt="" coords="1115,131,1187,158"/>
<area shape="rect" title=" " alt="" coords="1211,131,1325,158"/>
<area shape="rect" href="exponential__filter_8hpp.html" title="Implementation of an exponential filter." alt="" coords="1350,124,1565,165"/>
<area shape="rect" href="spatial__hash_8hpp.html" title="Implementation of a spatial hash for N dimensional states." alt="" coords="381,131,561,158"/>
<area shape="rect" href="type__traits_8hpp.html" title="Includes all beluga type traits." alt="" coords="857,131,1025,158"/>
<area shape="rect" title=" " alt="" coords="960,392,1171,419"/>
<area shape="rect" title=" " alt="" coords="1589,131,1793,158"/>
<area shape="rect" title=" " alt="" coords="1817,131,1991,158"/>
<area shape="rect" title=" " alt="" coords="2016,124,2163,165"/>
<area shape="rect" title=" " alt="" coords="2187,124,2333,165"/>
<area shape="rect" title=" " alt="" coords="499,221,557,247"/>
<area shape="rect" title=" " alt="" coords="89,221,151,247"/>
<area shape="rect" title=" " alt="" coords="176,221,243,247"/>
<area shape="rect" title=" " alt="" coords="855,392,910,419"/>
<area shape="rect" title=" " alt="" coords="677,392,769,419"/>
<area shape="rect" title=" " alt="" coords="267,221,327,247"/>
<area shape="rect" title=" " alt="" coords="352,221,475,247"/>
<area shape="rect" href="container__traits_8hpp.html" title="Useful traits for containers." alt="" coords="587,303,743,344"/>
<area shape="rect" href="particle__traits_8hpp.html" title="Implementation of traits for particle types, see the Particle named requirements." alt="" coords="869,213,1013,255"/>
<area shape="rect" title=" " alt="" coords="489,392,652,419"/>
<area shape="rect" href="views_8hpp.html" title="Implementation of useful container views." alt="" coords="920,310,1056,337"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sampling_8hpp__dep__incl.png" border="0" usemap="#a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep" alt=""/></div>
<map name="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep" id="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep">
<area shape="rect" title="Implementation of algorithms related to generation, sampling and resampling of particles." alt="" coords="72,5,265,76"/>
<area shape="rect" href="particle__filter_8hpp.html" title="Implementation of particle filters." alt="" coords="5,124,199,195"/>
<area shape="rect" href="algorithm_8hpp.html" title="Includes all beluga algorithms." alt="" coords="61,243,277,299"/>
<area shape="rect" href="beluga_8hpp.html" title="Includes all the beluga API." alt="" coords="70,347,267,403"/>
</map>
</div>
</div>
<p><a href="sampling_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1BaselineGeneration.html">beluga::BaselineGeneration&lt; Mixin, RandomNumberGenerator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A particle generator.  <a href="structbeluga_1_1BaselineGeneration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1NaiveGeneration.html">beluga::NaiveGeneration&lt; Mixin, RandomNumberGenerator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generation of samples from input particles.  <a href="structbeluga_1_1NaiveGeneration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1AdaptiveGenerationParam.html">beluga::AdaptiveGenerationParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct an <a class="el" href="structbeluga_1_1AdaptiveGeneration.html">AdaptiveGeneration</a> instance.  <a href="structbeluga_1_1AdaptiveGenerationParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1AdaptiveGeneration.html">beluga::AdaptiveGeneration&lt; Mixin, RandomNumberGenerator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1FixedResamplingParam.html">beluga::FixedResamplingParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="structbeluga_1_1FixedResamplingParam.html" title="Parameters used to construct a FixedResamplingParam instance.">FixedResamplingParam</a> instance.  <a href="structbeluga_1_1FixedResamplingParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1FixedResampling.html">beluga::FixedResampling&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resampling policy that uses a fixed number of particles.  <a href="structbeluga_1_1FixedResampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1KldResamplingParam.html">beluga::KldResamplingParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="structbeluga_1_1KldResampling.html" title="Resampling policy that adapts the number of particles according to the KLD criteria.">KldResampling</a> instance.  <a href="structbeluga_1_1KldResamplingParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1KldResampling.html">beluga::KldResampling&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resampling policy that adapts the number of particles according to the KLD criteria.  <a href="structbeluga_1_1KldResampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44e8e08696f783db65b95e70b4cf5c63"><td class="memTemplParams" colspan="2">template&lt;class Function1 , class Function2 , class RandomNumberGenerator &gt; </td></tr>
<tr class="memitem:a44e8e08696f783db65b95e70b4cf5c63"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a44e8e08696f783db65b95e70b4cf5c63">beluga::random_select</a> (Function1 first, Function2 second, RandomNumberGenerator &amp;generator, double probability)</td></tr>
<tr class="memdesc:a44e8e08696f783db65b95e70b4cf5c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between executing one function or another randomly.  <a href="sampling_8hpp.html#a44e8e08696f783db65b95e70b4cf5c63">More...</a><br /></td></tr>
<tr class="separator:a44e8e08696f783db65b95e70b4cf5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c342c9b7f61d63964b39b75c9bff84"><td class="memTemplParams" colspan="2">template&lt;class Range , class Weights , class RandomNumberGenerator &gt; </td></tr>
<tr class="memitem:a36c342c9b7f61d63964b39b75c9bff84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a36c342c9b7f61d63964b39b75c9bff84">beluga::random_sample</a> (const Range &amp;samples, const Weights &amp;weights, RandomNumberGenerator &amp;generator)</td></tr>
<tr class="memdesc:a36c342c9b7f61d63964b39b75c9bff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks a sample randomly from a range according to the weights of the samples.  <a href="sampling_8hpp.html#a36c342c9b7f61d63964b39b75c9bff84">More...</a><br /></td></tr>
<tr class="separator:a36c342c9b7f61d63964b39b75c9bff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3067c4d9759031795ba98ac43dc80dc7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a3067c4d9759031795ba98ac43dc80dc7">beluga::set_cluster</a> (double resolution)</td></tr>
<tr class="memdesc:a3067c4d9759031795ba98ac43dc80dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that allows setting the cluster of a particle.  <a href="sampling_8hpp.html#a3067c4d9759031795ba98ac43dc80dc7">More...</a><br /></td></tr>
<tr class="separator:a3067c4d9759031795ba98ac43dc80dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">beluga::kld_condition</a> (std::size_t min, double epsilon, double z=3.)</td></tr>
<tr class="memdesc:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that verifies if the kld condition is being satisfied.  <a href="sampling_8hpp.html#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">More...</a><br /></td></tr>
<tr class="separator:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of algorithms related to generation, sampling and resampling of particles. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4ef2ecb4492a73ec5d8c0c1c10b7ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">&#9670;&nbsp;</a></span>kld_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::kld_condition </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em> = <code>3.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that verifies if the kld condition is being satisfied. </p>
<p>The callable object will compute the minimum number of samples based on a Kullback-Leibler distance epsilon between the maximum likelihood estimate and the true distribution. Z is the upper standard normal quantile for P, where P is the probability that the error in the estimated distribution will be less than epsilon. Here are some examples:</p><ul>
<li>P = 0.900 -&gt; Z = 1.28155156327703</li>
<li>P = 0.950 -&gt; Z = 1.64485362793663</li>
<li>P = 0.990 -&gt; Z = 2.32634787735669</li>
<li>P = 0.999 -&gt; Z = 3.09023224677087</li>
</ul>
<p>If the computed value is less than what the min argument specifies, then min will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number of particles that the callable object will return. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum distance epsilon between the maximum likelihood estimate and the true distrubution. </td></tr>
    <tr><td class="paramname">z</td><td>Upper standard normal quantile for the probability that the error in the estimated distribution is less than epsilon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype (std::size_t hash) -&gt; bool. hash is the spatial hash of the particle being added. The returned callable object is stateful, tracking the total number of particles and the particle clusters based on the spatial hash. The return value will be false when the number of particles is more than the minimum and the kld condition is satisfied, if not it will be true. i.e. A return value of true means that you need to keep sampling to satisfy the condition. </dd></dl>

</div>
</div>
<a id="a36c342c9b7f61d63964b39b75c9bff84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c342c9b7f61d63964b39b75c9bff84">&#9670;&nbsp;</a></span>random_sample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class Weights , class RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::random_sample </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weights &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks a sample randomly from a range according to the weights of the samples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> type, its iterator must be <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">random access</a>. </td></tr>
    <tr><td class="paramname">Weights</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> type, its values must be convertible to double. </td></tr>
    <tr><td class="paramname">RandomNumberGenerator</td><td>Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator">UniformRandomBitGenerator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The container of samples to be picked. </td></tr>
    <tr><td class="paramname">weights</td><td>The weights of the samples to be picked. The size of the container must be the same as the size of samples. For a sample samples[i], its weight is weights[i]. </td></tr>
    <tr><td class="paramname">generator</td><td>The random number generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The picked sample. Its type is the same as the Range value type. </dd></dl>

</div>
</div>
<a id="a44e8e08696f783db65b95e70b4cf5c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e8e08696f783db65b95e70b4cf5c63">&#9670;&nbsp;</a></span>random_select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function1 , class Function2 , class RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::random_select </td>
          <td>(</td>
          <td class="paramtype">Function1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function2&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>probability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects between executing one function or another randomly. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function1</td><td>Callable type, with prototype () -&gt; Ret. </td></tr>
    <tr><td class="paramname">Function2</td><td>Callable type, with prototype () -&gt; Ret. The return type of both Function1 and Function2 must be the same. </td></tr>
    <tr><td class="paramname">RandomNumberGenerator</td><td>Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator">UniformRandomBitGenerator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first function to be called. </td></tr>
    <tr><td class="paramname">second</td><td>The second function to be called. </td></tr>
    <tr><td class="paramname">generator</td><td>The random number generator used. </td></tr>
    <tr><td class="paramname">probability</td><td>The first function will be called with the probability specified here. In the rest of the cases, second is called. A Bernoully distribution is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the called function. The return type is decltype(first()). </dd></dl>

</div>
</div>
<a id="a3067c4d9759031795ba98ac43dc80dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3067c4d9759031795ba98ac43dc80dc7">&#9670;&nbsp;</a></span>set_cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::set_cluster </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that allows setting the cluster of a particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>The size along any axis of the spatial cluster cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype (ParticleT &amp;&amp; p) -&gt; ParticleT. ParticleT must satisfy the <a class="el" href="ParticlePage.html">Particle</a> named requirements. The expression particle_traits&lt;ParticleT&gt;::cluster(p) must also be valid and return a <code>std::size_t &amp;</code>. After the returned object is applied to a particle p, cluster(p) will be updated with the calculated spatial hash according to the specified resolution. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
